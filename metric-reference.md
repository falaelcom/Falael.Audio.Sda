# Falael.Audio.Sda

A multi-band audio analysis system that extracts technical and perceptual metrics (dynamics, frequency response, harmonics, quantization, stereo imaging) from audio files, outputting a fingerprint in the form of a structured JSON data and charts for comprehensive audio quality assessment and comparison.

### Basics

Audio files are split into 30s chunks and the full spectrum is split into 10 logarithmic bands:

|Band|Description
|--|-- 
| `   20 -    40 Hz` | Sub-bass (felt more than heard, rumble, kick drum fundamentals)
| `   40 -    80 Hz` | Bass fundamentals (bass guitar, kick drum body, low piano notes)
| `   80 -   161 Hz` | Upper bass (bass guitar harmonics, male vocal fundamentals, low brass)
| `  161 -   323 Hz` | Low midrange (vocal fundamentals, guitar body, snare drum body)
| `  323 -   648 Hz` | Lower midrange (vocal clarity, guitar warmth, piano middle register)
| `  648 -  1299 Hz` | Midrange (vocal presence, guitar definition, brass instruments)
| ` 1299 -  2605 Hz` | Upper midrange (vocal intelligibility, guitar attack, brass brightness)
| ` 2605 -  5223 Hz` | Presence (vocal sibilance, cymbal attack, instrument clarity)
| ` 5223 - 10473 Hz` | Brilliance (cymbal shimmer, vocal air, string instrument harmonics)
| `10473 - 21000 Hz` | Air/sparkle (extreme highs, cymbal sizzle, spatial information)

All metrics are calculated per (band, chunk) pair, unless explicitly specified otherwise, in which case the same full-spectrum value is provided for all bands.

Per-band metrics are performed on signal that is that bandpass-filtered 4th-order Butterworth filter:

`py/x2/lib/bandpass_filter.py`
```python
def bandpass(data, rate, low, high):
    nyq = 0.5 * rate
    if high / nyq >= 1.0 or low / nyq <= 0: raise ValueError("Digital filter critical frequencies must be 0 < Wn < 1")
    sos = scipy.signal.butter(4, [low / nyq, high / nyq], btype='band', output='sos')
    return scipy.signal.sosfilt(sos, data)
```

Only metrics that appear in fingerprint images have a label and a normalization function specified. A list of all metrics is available after the __Image-Only Metrics__.

Metrics for the last track chunk might be distorted as all metrics are optimized for 30s chunk processing, and the last chunk is usually much shorter. For very short chunks, some metrics don't have meaning and a default value .

#### Normalization

Definition ranges of all metrics that appear in charts are normalized either to unipolar `(0, 1)` or bipolar `(-1, 1)` normalized ranges. Metrics are plotted as follows 

- Unipolar `(0, 1)` - 1 as primary color, 0 as gray;
- Bipolar `(-1, 1)` - 1 as primary color, 0 as saturated gray, -1 as complementary color;

where data point primary and complementary colors are generated automatically across the full color spectrum (primary colors span half spectrum and complementary colors span naturally the other half of the spectrum).

Normalization functions have been designed to match the default configuration of chunk (30s per chunk) and band (10 bands from 20Hz to 21kHz) splitting. If these values change, normalization functions will most likely need adjustment.

### Image-Only Metrics (in order of appearance in charts)

|key|title|label|def. range|norm. fn|description|algo (py)
|--|--|--|--|--|--|--
|`audio_quality::avg_sinad_db`| Average SINAD (dB) | `SINAD` | 0 to 120 dB | Unipolar `(0, 1)` <br /> Sigmoid normalization: <br /> -- 40.0 dB → 0.05 (poor quality), <br /> -- 70.0 dB → 0.95 (high-end audio). <br /> Maps signal-to-noise-and-distortion ratio to audio quality - higher values indicate cleaner signal with less noise and distortion. | Average signal-to-noise-and-distortion ratio of the full-spectrum signal (all bands have the same value, that ot the full-spectrum analysis) calculated from FFT frame analysis. Measures the ratio of total signal energy to noise floor energy across all frequency bins. Higher values indicate better signal quality with lower noise and distortion levels. | SINAD calculation from FFT spectrum analysis: <br /> `windowed = frame * np.hanning(fft_size)` <br /> `fft_mag = np.abs(np.fft.rfft(windowed))` <br /> `total_energy = np.sum(fft_mag ** 2)` <br /> `noise_energy = (noise_floor_mag ** 2) * len(fft_mag)` <br /> `sinad_db = 10 * np.log10(total_energy / noise_energy)` <br /> `avg_sinad_db = np.mean([frame_sinads])`
|`audio_quality::std_sinad_db`| SINAD Stability (dB) | `SINAD.stab` | 0 to 30 dB | Bipolar `(-1, 1)` <br /> Inverted sigmoid normalization: <br /> -- 0.0 dB → 0.95 (perfect stability), <br /> -- 8.0 dB → 0.0 (neutral stability), <br /> -- 16.0 dB → -0.95 (very poor stability). <br /> Maps SINAD variation to stability quality - lower standard deviation indicates more consistent signal quality. | Standard deviation of signal-to-noise-and-distortion ratio across all analyzed frames in the full-spectrum signal (all bands have the same value, that ot the full-spectrum analysis). Measures the consistency of signal quality within the chunk. Lower values indicate stable signal quality, higher values suggest varying noise/distortion levels. | SINAD standard deviation calculation from FFT frame analysis: <br /> `windowed = frame * np.hanning(fft_size)` <br /> `fft_mag = np.abs(np.fft.rfft(windowed))` <br /> `total_energy = np.sum(fft_mag ** 2)` <br /> `noise_energy = (noise_floor_mag ** 2) * len(fft_mag)` <br /> `sinad_db = 10 * np.log10(total_energy / noise_energy)` <br /> `std_sinad_db = np.std([frame_sinads])`
|`audio_quality::spectral_flatness_ratio`| Overall Musicality | `ovrl.mus` | 0.0 to 1.0 | Bipolar `(-1, 1)` <br /> Musical center normalization: <br /> -- 0.3-0.5 → 0.95 (musical sweet spot), <br /> -- 0.4 → 0.95 (optimal musicality), <br /> -- 0.0 or 1.0 → -0.95 (extreme penalty). <br /> Maps spectral flatness to musicality with quality declining away from natural musical range. Values in sweet spot indicate musical content, extreme values indicate pure tones or noise. | Spectral flatness ratio of the full-spectrum signal (all bands have the same value, that ot the full-spectrum analysis) measuring overall musicality. Represents the balance between tonal and noise-like characteristics across the entire frequency range. Values around 0.4 indicate optimal musical content, while values near 0.0 (pure tones) or 1.0 (pure noise) receive negative scores. | spectral flatness ratio from full-spectrum analysis: <br /> `spectral_flatness_ratio = geometric_mean / arithmetic_mean` <br /> `flatness_ratio = geo_mean / arith_mean` <br /> (from harmonics_full_spectrum analysis)
|`harmonics::richness_db`| Musical Richness (dB) | `mus.rich` | 0 to 100 dB | Unipolar `(0, 1)` <br /> Sigmoid normalization: <br /> -- 0 dB → 0.05 (flat/boring), <br /> -- 100 dB → 0.95 (rich musical content). <br /> Maps spectral flatness to musical richness - higher values indicate more tonal/harmonic content. | Spectral flatness of the bandpass-filtered signal converted to dB scale. Measures how tonal vs. noise-like the frequency band is. Lower flatness (higher dB values) indicates more harmonic/musical content, higher flatness (lower dB values) indicates more noise-like content. | spectral flatness analysis using overlapping FFT frames: <br /> `windowed = frame * np.hanning(fft_size)` <br /> `mag = np.abs(np.fft.rfft(windowed))` <br /> `geo_mean = np.exp(np.mean(np.log(mag_spectrum)))` <br /> `arith_mean = np.mean(mag_spectrum)` <br /> `flatness = geo_mean / arith_mean` <br /> `richness_db = -np.log10(flatness) * 10`
|`stereo_width::presence`| Stereo Presence | `st.presence` | 0.0 to 1.0 | Unipolar `(0, 1)` <br /> Linear clipping normalization: <br /> -- 0.0 → 0.0 (no stereo presence), <br /> -- 1.0 → 1.0 (full stereo presence). <br /> Maps stereo width to presence perception using exponential saturation curve. | Stereo presence derived from width ratio using exponential approach to saturation. Measures the perceived stereo width within the frequency band. Values approach 1.0 asymptotically as width increases, representing diminishing returns of very wide stereo content. <br /> <br /> A visualization component of `stereo_width::width_ratio`. | exponential presence calculation from width ratio: <br /> `width_ratio = side_amplitude / mid_amplitude` <br /> `presence = 1 - np.exp(-width_ratio * 2.0 / 2.0)` <br /> `presence = 1 - np.exp(-width_ratio)`
|`stereo_width::quality`| Stereo Naturalness | `st.natrl` | -1.0 to 1.0 | Bipolar `(-1, 1)` <br /> Linear clipping normalization: <br /> -- -1.0 → -1.0 (completely broken), <br /> -- 0.0 → 0.0 (poor quality), <br /> -- 1.0 → 1.0 (perfect quality). <br /> Maps stereo width to naturalness perception using piecewise quality function. | Stereo quality derived from width ratio using piecewise function. Measures the naturalness of stereo width within the frequency band. Values above 0 indicate natural stereo, values below 0 indicate problematic phase or width issues. <br /> <br /> A visualization component of `stereo_width::width_ratio`. | piecewise quality calculation from width ratio: <br /> `if width_ratio < 1.0: quality = 1.0` <br /> `elif width_ratio <= 2.0: quality = 1.0 - (width_ratio - 1.0)` <br /> `elif width_ratio <= 2.3: quality = -0.95 * (width_ratio - 2.0) / 0.3` <br /> `else: quality = -1.0`
|`stereo_correlation::correlation`| Stereo Correlation | `st.corr` | -1.0 to 1.0 | Bipolar `(-1, 1)` <br /> Linear clipping normalization: <br /> -- -1.0 → -1.0 (anti-correlated), <br /> -- 0.0 → 0.0 (uncorrelated), <br /> -- 1.0 → 1.0 (perfectly correlated). <br /> Maps linear relationship between stereo channels - values indicate amplitude correlation between left and right channels. | Correlation coefficient between left and right channels in the bandpass-filtered signal. Measures the similarity between stereo channels within the frequency band. Values near 1.0 indicate highly correlated (mono-like) content, values near 0.0 indicate uncorrelated content, and values near -1.0 indicate anti-correlated content. | stereo correlation calculation using Pearson correlation: <br /> `left_band = bandpass(left, rate, f_low, f_high)` <br /> `right_band = bandpass(right, rate, f_low, f_high)` <br /> `correlation = np.corrcoef(left_band, right_band)[0, 1]`
|`stereo_phase::coherence`| Stereo Phase Coherence | `st.phase` | -1.0 to 1.0 | Bipolar `(-1, 1)` <br /> Linear clipping normalization: <br /> -- -1.0 → -1.0 (perfect anti-phase), <br /> -- 0.0 → 0.0 (random phases), <br /> -- +1.0 → +1.0 (perfect in-phase). <br /> Maps phase relationship between stereo channels - values indicate degree of phase alignment across frequency spectrum. | Phase coherence between left and right channels in the bandpass-filtered signal using windowed FFT phase analysis. Measures energy-weighted phase alignment of stereo channels within the frequency band. Values near +1.0 indicate strong in-phase coherence (mono-like content), values near 0.0 indicate random phase relationships (wide stereo content), values near -1.0 indicate anti-phase relationships (mono cancellation risk). **Note: Slower analysis due to FFT processing with overlapping windows.** | Energy-weighted phase coherence calculation using overlapping FFT windows: <br /> `left_fft = np.fft.fft(left_windowed)` <br /> `right_fft = np.fft.fft(right_windowed)` <br /> `phase_diff = np.angle(left_fft) - np.angle(right_fft)` <br /> `weights = (left_mag² + right_mag²) / sum(energies)` <br /> `coherence = np.average(np.cos(phase_diff), weights=weights)` <br /> Averaged across overlapping time windows (75% overlap by default)
|`quantization::avg_noise_floor_db`| Quantization Noise Floor (dB) | `noise Q` | -200 to -20 dBFS | Unipolar `(0, 1)` <br /> Inverted sigmoid normalization: <br /> -- -200 dBFS → 0.95 (excellent quality), <br /> -- -20 dBFS → 0.05 (poor quality). <br /> Maps quantization noise floor to audio quality - lower noise floors indicate better quantization quality. | Average noise floor level of the bandpass-filtered signal calculated from FFT spectrum analysis. Measures the background quantization noise level. Lower values indicate less quantization noise and higher digital audio quality. | noise floor estimation from FFT spectrum: <br /> `windowed = frame * np.hanning(frame_size)` <br /> `fft_mag = np.abs(np.fft.fft(windowed))` <br /> `noise_floor = np.percentile(fft_mag, percentile)` <br /> `noise_floor_db = 20 * np.log10(noise_floor)` <br /> `avg_noise_floor_db = np.mean([artifacts['noise_floor_db']])`
|`quantization::noise_floor_std_db`| Noise Floor Stability (dB) | `noise st` | 0 to 40 dB | Unipolar `(0, 1)` <br /> Inverted sigmoid normalization: <br /> -- 0.0 dB → 0.95 (perfect consistency), <br /> -- 20.0 dB → 0.05 (high variability). <br /> Maps noise floor variability to stability quality - lower standard deviation indicates more consistent quantization noise. | Standard deviation of noise floor measurements across all frames in the bandpass-filtered signal. Measures the consistency of quantization noise levels. Lower values indicate stable quantization behavior, higher values suggest variable or problematic quantization. | noise floor standard deviation from FFT analysis: <br /> `windowed = frame * np.hanning(frame_size)` <br /> `fft_mag = np.abs(np.fft.fft(windowed))` <br /> `noise_floor_db = 20 * np.log10(np.percentile(fft_mag, percentile))` <br /> `noise_floor_std_db = np.std([artifacts['noise_floor_db']])`
|`quantization::dynamic_range_db`| Dynamic Range (dB) | `dyn.rng` | 0 to 300 dB | Bipolar `(-1, 1)` <br /> Piecewise sigmoid normalization: <br /> -- 20.0 dB → -0.95 (practical minimum), <br /> -- 110.0 dB → 0.0 (midpoint), <br /> -- 200.0 dB → 0.95 (practical maximum). <br /> Maps dynamic range to audio quality - higher values indicate better separation between signal and noise floor. | Dynamic range of the bandpass-filtered signal calculated as the difference between peak level and average noise floor. Measures the separation between the loudest signal content and the quantization noise floor. Higher values indicate better signal-to-noise ratio and quantization quality. | dynamic range calculation from peak and noise floor: <br /> `peak_level = 20 * np.log10(np.max(np.abs(band_signal)))` <br /> `avg_noise_floor = np.mean([artifacts['noise_floor_db']])` <br /> `dynamic_range_db = peak_level - avg_noise_floor`
|`dynamic_range::peak_to_noise_ratio_db`| Peak-to-Noise Ratio (dB) | `dyn.PTNR` | 0 to 300 dB | Bipolar `(-1, 1)` <br /> Sigmoid normalization: <br /> -- 40.0 dB → -0.95 (poor quality), <br /> -- 120.0 dB → 0.0 (neutral quality), <br /> -- 200.0 dB → 0.95 (excellent quality). <br /> Maps peak-to-noise ratio to dynamic range quality - higher values indicate better separation between signal peaks and noise floor. | Peak-to-noise ratio calculated as the difference between bandpass-filtered signal peak level and quantization noise floor. Measures the dynamic range between the loudest signal content and the noise floor within the frequency band. Higher values indicate better signal-to-noise performance and lower noise floor. | peak-to-noise ratio calculation: <br /> `peak_dbfs = dynamics_peak_level` <br /> `noise_floor_db = quantization_avg_noise_floor_db` <br /> `peak_to_noise_ratio_db = peak_dbfs - noise_floor_db`
|`dynamic_range::signal_to_noise_ratio_db`| Signal-to-Noise Ratio (dB) | `dyn.STNR` | 0 to 200 dB | Bipolar `(-1, 1)` <br /> Sigmoid normalization: <br /> -- 20.0 dB → -0.95 (poor quality), <br /> -- 100.0 dB → 0.0 (neutral quality), <br /> -- 180.0 dB → 0.95 (excellent quality). <br /> Maps signal-to-noise ratio to dynamic range quality - higher values indicate better separation between average signal level and noise floor. | Signal-to-noise ratio calculated as the difference between bandpass-filtered signal RMS level and quantization noise floor. Measures the dynamic range between the average signal content and the noise floor within the frequency band. Higher values indicate better signal-to-noise performance and cleaner audio quality. | signal-to-noise ratio calculation: <br /> `rms_dbfs = dynamics_rms_level` <br /> `noise_floor_db = quantization_avg_noise_floor_db` <br /> `signal_to_noise_ratio_db = rms_dbfs - noise_floor_db`
|`dynamic_range::overall_avg_crest_factor_db`| Overall Average Crest Factor (dB) | `ovrl.dyn` | 0 to 30 dB | Bipolar `(-1, 1)` <br /> Sigmoid normalization: <br /> -- 3.0 dB → -0.95 (heavily compressed), <br /> -- 8.0 dB → 0.0 (neutral dynamics), <br /> -- 16.0 dB → 0.95 (natural dynamics). <br /> Maps overall crest factor to dynamic range quality - higher values indicate more natural, less compressed audio. | Overall average crest factor of the full-spectrum signal (all bands have the same value, that ot the full-spectrum analysis) representing the global dynamic character. Measures the average peak-to-RMS ratio across all frames in the entire frequency spectrum. Higher values indicate more natural dynamics, lower values suggest compression or limiting. | overall crest factor from full-spectrum dynamics analysis: <br /> `overall_avg_crest_factor_db = dynamics_full_spectrum_avg_crest_factor_db`
|`dynamics::crest_factor_db`| Crest Factor (dB) | `dynamics` | 0 to 96 dB | Unipolar `(0, 1)` <br /> Sigmoid normalization: <br /> -- 3 dB → 0.05 (compressed), <br /> -- 20 dB → 0.95 (natural dynamics). <br /> Maps heavily compressed audio to low values, natural dynamics to high values. | Difference between peak and RMS level of the bandpass-filtered signal. Indicates the dynamic character of the frequency band - lower values suggest more compressed/consistent levels, higher values indicate more transient/impulsive content. | difference between peak and RMS level of the bandpass-filtered signal: <br /> `crest_factor_db = peak_dbfs - rms_dbfs  # only if both are not -inf`
|`dynamics::avg_crest_factor_db`| Crest Frame Factor Avg. (dB) | `avg.dyn` | 0 to 96 dB | Unipolar `(0, 1)` <br /> Sigmoid normalization: <br /> -- 3 dB → 0.05 (compressed), <br /> -- 16 dB → 0.95 (natural dynamics). <br /> Maps heavily compressed audio to low values, natural dynamics to high values. | Mean crest factor across all frames within the frequency band, using noise floor for zero-RMS frames. Represents the average ratio of peak-to-RMS levels throughout the chunk - higher values indicate consistently transient/impulsive content, lower values suggest more sustained character. | mean crest factor across all frames, using noise floor for zero-RMS frames: <br /> `frame_crest_factors = [peak / max(rms, 1e-12) for peak, rms in zip(frame_peaks, frame_rms)]` <br/> `avg_crest_factor = np.mean(frame_crest_factors)` <br/> `avg_crest_factor_db = 20 * np.log10(avg_crest_factor)`
|`freq_response::avg_magnitude_db`| Relative Frequency Balance (dB) | `rel.lvl` | -60 to 30 dB | Bipolar `(-1, 1)` <br /> Sigmoid normalization: <br /> -- -3 dB → 0.0 (neutral), <br /> -- -30 dB → -0.95 (low extreme), <br /> -- 10 dB → 0.95 (high extreme). <br /> Maps frequency balance relative to uniform distribution. | Relative energy density of the frequency band compared to uniform distribution across the 20 Hz to 21,000 Hz analysis range. Calculated using overlapping FFT frames with Hanning window. Positive values indicate the band is louder than average, negative values indicate it's quieter than average. | FFT-based frequency analysis with overlapping frames: <br /> `windowed = frame * np.hanning(fft_size)` <br /> `fft_mag = np.abs(np.fft.rfft(windowed))` <br /> `avg_fft = np.mean(frames_ffts, axis=0)` <br /> `band_energy_density = band_energy / band_width` <br /> `balance_db = 20 * np.log10(band_energy_density / expected_energy_density)`
|`quantization::estimated_bits`| Estimated Bit Depth | `bit depth` | 1 to 32 bits | Unipolar `(0, 1)` <br /> Sigmoid normalization: <br /> -- 6.0 bits → 0.05 (very poor), <br /> -- 24.0 bits → 0.95 (excellent quality). <br /> Maps effective bit depth to audio quality - higher values indicate better quantization resolution. | Estimated effective bit depth of the bandpass-filtered signal by analyzing quantization levels. Measures the resolution of the digital audio quantization. Higher bit depths indicate finer amplitude resolution and lower quantization noise. | bit depth estimation from unique amplitude levels: <br /> `signal = signal - np.mean(signal)` <br /> `sorted_signal = np.sort(np.abs(signal[signal != 0]))` <br /> `unique_levels = count_unique_with_tolerance(sorted_signal)` <br /> `estimated_bits = np.log2(num_levels * 2)`
|`quantization::unique_levels`| Digital Resolution | `digit.res` | 1 to 1000000 levels | Unipolar `(0, 1)` <br /> Logarithmic normalization: <br /> -- 100 levels → 0.0 (poor quality), <br /> -- 100000 levels → 0.95 (excellent quality). <br /> Maps number of unique amplitude levels to digital resolution quality - higher values indicate finer quantization resolution. | Number of unique amplitude levels detected in the bandpass-filtered signal with tolerance for floating point precision. Measures the granularity of the digital audio quantization. More unique levels indicate higher resolution and less coarse quantization. | unique amplitude level counting with tolerance: <br /> `signal = signal - np.mean(signal)` <br /> `sorted_signal = np.sort(np.abs(signal[signal != 0]))` <br /> `unique_levels = count_unique_with_tolerance(sorted_signal, tolerance)` <br /> `num_levels = len(unique_levels)`
|`audio_quality::quantization_efficiency`| Quantization Efficiency | `dither.effy` | 0.0 to 1.0+ | Unipolar `(0, 1)` <br /> Triangular normalization: <br /> -- ≤0.25 → 0.0 (underused quantization), <br /> -- 0.575 → 1.0 (natural utilization), <br /> -- ≥0.85 → 0.0 (overused quantization). <br /> Maps ratio of actual to theoretical quantization levels with quality declining away from natural point. Lower values indicate underutilized quantization, higher values indicate overutilized/artificial quantization. | Efficiency ratio of actual unique amplitude levels to theoretical levels based on estimated bit depth. Measures quantization utilization within the frequency band. Values around 0.575 represent natural audio characteristics, while deviation in either direction suggests quality issues - underutilization (too few levels used) or overutilization (unnaturally high level usage). Note: 0.575 as optimal point is an assumption based on typical natural audio behavior. | quantization efficiency calculation: <br /> `theoretical_levels = 2 ** estimated_bits` <br /> `quantization_efficiency = unique_levels / theoretical_levels`
|`quantization::avg_spectral_slope_db`| Dithering Quality (dB) | `dither Q` | -60 to 20 dB | Bipolar `(-1, 1)` <br /> Sigmoid normalization: <br /> -- -20.0 dB → 0.95 (natural rolloff, good), <br /> -- -5.0 dB → 0.0 (moderate rolloff, neutral), <br /> -- 10.0 dB → -0.95 (flat/boosted highs, poor). <br /> Maps spectral slope to dithering quality - steeper negative slopes indicate better quantization behavior. | Average spectral slope between mid and high frequencies in the bandpass-filtered signal. Measures the high-frequency rolloff characteristics which indicate quantization noise patterns. Steeper negative slopes suggest natural rolloff, flatter slopes indicate quantization artifacts or poor dithering. | spectral slope calculation from FFT analysis: <br /> `windowed = frame * np.hanning(frame_size)` <br /> `fft_mag = np.abs(np.fft.fft(windowed))` <br /> `mid_energy = np.mean(fft_mag[mid_idx:high_idx])` <br /> `high_energy = np.mean(fft_mag[high_idx:])` <br /> `spectral_slope_db = 20 * np.log10(high_energy / mid_energy)` <br /> `avg_spectral_slope_db = np.mean([artifacts['spectral_slope_db']])`
|`quantization::spectral_slope_std_db`| Dithering Stability (dB) | `dither st` | 0 to 30 dB | Unipolar `(0, 1)` <br /> Inverted sigmoid normalization: <br /> -- 0.0 dB → 0.95 (perfect consistency), <br /> -- 15.0 dB → 0.05 (high variability). <br /> Maps spectral slope variability to dithering stability - lower standard deviation indicates more consistent quantization behavior. | Standard deviation of spectral slope measurements across all frames in the bandpass-filtered signal. Measures the consistency of high-frequency rolloff characteristics. Lower values indicate stable quantization behavior, higher values suggest variable or problematic dithering. | spectral slope standard deviation from FFT analysis: <br /> `windowed = frame * np.hanning(frame_size)` <br /> `fft_mag = np.abs(np.fft.fft(windowed))` <br /> `spectral_slope_db = 20 * np.log10(high_energy / mid_energy)` <br /> `spectral_slope_std_db = np.std([artifacts['spectral_slope_db']])`
|`sparkle::sparkle`| Sparkle | `sparkle` | 0.0 to 2.0 | Unipolar `(0, 1)` <br /> Hybrid normalization: <br /> -- Linear up to 0.3 → 0.95, <br /> -- Exponential above 0.3 → 1.0. <br /> Maps high-frequency transient energy to sparkle perception - higher values indicate more high-frequency detail and brightness. | RMS energy of transients in the bandpass-filtered signal with bandwidth compensation. Measures high-frequency content and transient detail. Set to 0.0 for bands below 2kHz threshold. Higher values indicate more sparkle and high-frequency energy. | transient RMS calculation with bandwidth compensation: <br /> `frame = signal[i:i+frame_size]` <br /> `rms = np.sqrt(np.mean(np.square(frame)))` <br /> `sparkle_value = np.mean(frame_energy)` <br /> `band_octaves = np.log2(f_high / f_low)` <br /> `compensation_factor = total_octaves / band_octaves` <br /> `sparkle_compensated = sparkle_value * compensation_factor`


### All Metrics (JSON and image)

#### `dynamics`, `dynamics_full_spectrum`

|key|title|label|def. range|norm. fn|description|algo (py)
|--|--|--|--|--|--|--
|`dynamics::peak_dbfs`| Peak Level (dBFS) | - | -96 to 0 dBFS | - | Maximum absolute amplitude of the bandpass-filtered signal in dBFS. Represents the loudest instantaneous sample within the frequency band during the 30-second chunk. | max absolute amplitude of the bandpass-filtered signal, in dBFS, where signal is bandpass-filtered using 4th-order Butterworth filter: <br /> `peak = np.max(np.abs(signal))` <br /> `peak_db = 20 * np.log10(peak)  # if peak > 0 else -inf`
|`dynamics::rms_dbfs`| RMS Level (dBFS) | - | -96 to 0 dBFS | - | Root mean square amplitude of the bandpass-filtered signal in dBFS. Represents the average power level within the frequency band during the 30-second chunk, providing a measure of perceived loudness. | root mean square amplitude of the bandpass-filtered signal, in dBFS: <br /> `rms = np.sqrt(np.mean(signal ** 2))` <br/> `rms_dbfs = 20 * np.log10(rms)  # if rms > 0 else -inf`
|`dynamics::crest_factor_db`| Crest Factor (dB) | `dynamics` | 0 to 96 dB | Unipolar `(0, 1)` <br /> Sigmoid normalization: <br /> -- 3 dB → 0.05 (compressed), <br /> -- 20 dB → 0.95 (natural dynamics). <br /> Maps heavily compressed audio to low values, natural dynamics to high values. | Difference between peak and RMS level of the bandpass-filtered signal. Indicates the dynamic character of the frequency band - lower values suggest more compressed/consistent levels, higher values indicate more transient/impulsive content. | difference between peak and RMS level of the bandpass-filtered signal: <br /> `crest_factor_db = peak_dbfs - rms_dbfs  # only if both are not -inf`
|`dynamics::peak_dyn_range_db`| Peak Dynamic Range (dB) | - | 0 to 120 dB | - | Dynamic range between the quietest and loudest frame peaks within the frequency band. Measures the difference between minimum and maximum peak levels across all frames - higher values indicate greater contrast between quiet and loud moments. | dynamic range of frame-wise peak amplitudes, in dB: <br /> `min_peak = np.min(frame_peaks)` <br/> `max_peak = np.max(frame_peaks)` <br/> `peak_range_db = 20 * np.log10(max_peak / min_peak)  # or use noise floor if min_peak ~ 0`
|`dynamics::rms_dyn_range_db`| RMS Dynamic Range (dB) | - | 0 to 120 dB | - | Dynamic range between the quietest and loudest frame RMS levels within the frequency band. Measures the difference between minimum and maximum RMS levels across all frames - higher values indicate greater contrast between quiet and loud sustained periods. | dynamic range of frame-wise RMS amplitudes, in dB: <br /> `min_rms = np.min(frame_rms)` <br/> `max_rms = np.max(frame_rms)` <br/> `rms_range_db = 20 * np.log10(max_rms / min_rms)  # or use noise floor if min_rms ~ 0`
|`dynamics::avg_crest_factor_db`| Crest Frame Factor Avg. (dB) | `avg.dyn` | 0 to 96 dB | Unipolar `(0, 1)` <br /> Sigmoid normalization: <br /> -- 3 dB → 0.05 (compressed), <br /> -- 16 dB → 0.95 (natural dynamics). <br /> Maps heavily compressed audio to low values, natural dynamics to high values. | Mean crest factor across all frames within the frequency band, using noise floor for zero-RMS frames. Represents the average ratio of peak-to-RMS levels throughout the chunk - higher values indicate consistently transient/impulsive content, lower values suggest more sustained character. | mean crest factor across all frames, using noise floor for zero-RMS frames: <br /> `frame_crest_factors = [peak / max(rms, 1e-12) for peak, rms in zip(frame_peaks, frame_rms)]` <br/> `avg_crest_factor = np.mean(frame_crest_factors)` <br/> `avg_crest_factor_db = 20 * np.log10(avg_crest_factor)`
|`dynamics::crest_factor_std_db`| Crest Frame Factor Std. (dB) | - | 0 to 96 dB | - | Standard deviation of frame crest factors within the frequency band, scaled to dB. Measures the variability of peak-to-RMS ratios across frames - higher values indicate inconsistent dynamic character (mix of transient and sustained content), lower values suggest consistent behavior. | standard deviation of frame crest factors, scaled to dB: <br /> `crest_factor_std_db = np.std(frame_crest_factors)` <br/> `crest_factor_std_db = 20 * np.log10(crest_factor_std_db + 1e-12)`
|`dynamics_full_spectrum::peak_dbfs`| Peak Level (dBFS) | - | -96 to 0 dBFS | - | Maximum absolute amplitude of the full-spectrum signal in dBFS. Represents the loudest instantaneous sample during the 30-second chunk. | max absolute amplitude of the full-spectrum signal, in dBFS: <br /> `peak = np.max(np.abs(signal))` <br /> `peak_dbfs = 20 * np.log10(peak)  # if peak > 0 else -inf`
|`dynamics_full_spectrum::rms_dbfs`| RMS Level (dBFS) | - | -96 to 0 dBFS | - | Root mean square amplitude of the full-spectrum signal in dBFS. Represents the average power level during the 30-second chunk, providing a measure of perceived loudness. | root mean square amplitude of the full-spectrum signal, in dBFS: <br /> `rms = np.sqrt(np.mean(signal ** 2))` <br/> `rms_dbfs = 20 * np.log10(rms)  # if rms > 0 else -inf`
|`dynamics_full_spectrum::crest_factor_db`| Crest Factor (dB) | - | 0 to 96 dB | - | Difference between peak and RMS level of the full-spectrum signal. Indicates the dynamic character - lower values suggest more compressed/consistent levels, higher values indicate more transient/impulsive content. | difference between peak and RMS level of the full-spectrum signal: <br /> `crest_factor_db = peak_dbfs - rms_dbfs  # only if both are not -inf`
|`dynamics_full_spectrum::peak_dyn_range_db`| Peak Dynamic Range (dB) | - | 0 to 120 dB | - | Dynamic range between the quietest and loudest frame peaks in the full-spectrum signal. Measures the difference between minimum and maximum peak levels across all frames - higher values indicate greater contrast between quiet and loud moments. | dynamic range of frame-wise peak amplitudes, in dB: <br /> `min_peak = np.min(frame_peaks)` <br/> `max_peak = np.max(frame_peaks)` <br/> `peak_range_db = 20 * np.log10(max_peak / min_peak)  # or use noise floor if min_peak ~ 0`
|`dynamics_full_spectrum::rms_dyn_range_db`| RMS Dynamic Range (dB) | - | 0 to 120 dB | - | Dynamic range between the quietest and loudest frame RMS levels in the full-spectrum signal. Measures the difference between minimum and maximum RMS levels across all frames - higher values indicate greater contrast between quiet and loud sustained periods. | dynamic range of frame-wise RMS amplitudes, in dB: <br /> `min_rms = np.min(frame_rms)` <br/> `max_rms = np.max(frame_rms)` <br/> `rms_range_db = 20 * np.log10(max_rms / min_rms)  # or use noise floor if min_rms ~ 0`
|`dynamics_full_spectrum::avg_crest_factor_db`| Crest Frame Factor Avg. (dB) | - | 0 to 96 dB | - | Mean crest factor across all frames in the full-spectrum signal, using noise floor for zero-RMS frames. Represents the average ratio of peak-to-RMS levels throughout the chunk - higher values indicate consistently transient/impulsive content, lower values suggest more sustained character. | mean crest factor across all frames, using noise floor for zero-RMS frames: <br /> `frame_crest_factors = [peak / max(rms, 1e-12) for peak, rms in zip(frame_peaks, frame_rms)]` <br/> `avg_crest_factor = np.mean(frame_crest_factors)` <br/> `avg_crest_factor_db = 20 * np.log10(avg_crest_factor)`
|`dynamics_full_spectrum::crest_factor_std_db`| Crest Frame Factor Std. (dB) | - | 0 to 96 dB | - | Standard deviation of frame crest factors in the full-spectrum signal, scaled to dB. Measures the variability of peak-to-RMS ratios across frames - higher values indicate inconsistent dynamic character (mix of transient and sustained content), lower values suggest consistent behavior. | standard deviation of frame crest factors, scaled to dB: <br /> `crest_factor_std_db = np.std(frame_crest_factors)` <br/> `crest_factor_std_db = 20 * np.log10(crest_factor_std_db + 1e-12)`


#### `freq_response`

|key|title|label|def. range|norm. fn|description|algo (py)
|--|--|--|--|--|--|--
|`freq_response::avg_magnitude_db`| Relative Frequency Balance (dB) | `rel.lvl` | -60 to 30 dB | Bipolar `(-1, 1)` <br /> Sigmoid normalization: <br /> -- -3 dB → 0.0 (neutral), <br /> -- -30 dB → -0.95 (low extreme), <br /> -- 10 dB → 0.95 (high extreme). <br /> Maps frequency balance relative to uniform distribution. | Relative energy density of the frequency band compared to uniform distribution across the 20 Hz to 21,000 Hz analysis range. Calculated using overlapping FFT frames with Hanning window. Positive values indicate the band is louder than average, negative values indicate it's quieter than average. | FFT-based frequency analysis with overlapping frames: <br /> `windowed = frame * np.hanning(fft_size)` <br /> `fft_mag = np.abs(np.fft.rfft(windowed))` <br /> `avg_fft = np.mean(frames_ffts, axis=0)` <br /> `band_energy_density = band_energy / band_width` <br /> `balance_db = 20 * np.log10(band_energy_density / expected_energy_density)`


#### `harmonics`, `harmonics_full_spectrum`

|key|title|label|def. range|norm. fn|description|algo (py)
|--|--|--|--|--|--|--
|`harmonics::richness_db`| Musical Richness (dB) | `mus.rich` | 0 to 100 dB | Unipolar `(0, 1)` <br /> Sigmoid normalization: <br /> -- 0 dB → 0.05 (flat/boring), <br /> -- 100 dB → 0.95 (rich musical content). <br /> Maps spectral flatness to musical richness - higher values indicate more tonal/harmonic content. | Spectral flatness of the bandpass-filtered signal converted to dB scale. Measures how tonal vs. noise-like the frequency band is. Lower flatness (higher dB values) indicates more harmonic/musical content, higher flatness (lower dB values) indicates more noise-like content. | spectral flatness analysis using overlapping FFT frames: <br /> `windowed = frame * np.hanning(fft_size)` <br /> `mag = np.abs(np.fft.rfft(windowed))` <br /> `geo_mean = np.exp(np.mean(np.log(mag_spectrum)))` <br /> `arith_mean = np.mean(mag_spectrum)` <br /> `flatness = geo_mean / arith_mean` <br /> `richness_db = -np.log10(flatness) * 10`
|`harmonics_full_spectrum::spectral_flatness_ratio`| Spectral Flatness Ratio | - | 0.0 to 1.0 | - <br /> Maps spectral flatness ratio directly - higher values indicate more noise-like content. | Spectral flatness of the full-spectrum signal up to 16kHz band limit. Measures how tonal vs. noise-like the signal is. Higher values indicate more noise-like content, lower values indicate more harmonic/tonal content. Raw ratio without dB conversion. | spectral flatness analysis using overlapping FFT frames with band limiting: <br /> `windowed = frame * np.hanning(fft_size)` <br /> `mag = np.abs(np.fft.rfft(windowed))[:spectrum_bins]` <br /> `geo_mean = np.exp(np.mean(np.log(mag_spectrum)))` <br /> `arith_mean = np.mean(mag_spectrum)` <br /> `flatness_ratio = geo_mean / arith_mean`


#### `quantization`, `quantization_full_spectrum`

|key|title|label|def. range|norm. fn|description|algo (py)
|--|--|--|--|--|--|--
|`quantization::estimated_bits`| Estimated Bit Depth | `bit depth` | 1 to 32 bits | Unipolar `(0, 1)` <br /> Sigmoid normalization: <br /> -- 6.0 bits → 0.05 (very poor), <br /> -- 24.0 bits → 0.95 (excellent quality). <br /> Maps effective bit depth to audio quality - higher values indicate better quantization resolution. | Estimated effective bit depth of the bandpass-filtered signal by analyzing quantization levels. Measures the resolution of the digital audio quantization. Higher bit depths indicate finer amplitude resolution and lower quantization noise. | bit depth estimation from unique amplitude levels: <br /> `signal = signal - np.mean(signal)` <br /> `sorted_signal = np.sort(np.abs(signal[signal != 0]))` <br /> `unique_levels = count_unique_with_tolerance(sorted_signal)` <br /> `estimated_bits = np.log2(num_levels * 2)`
|`quantization::unique_levels`| Digital Resolution | `digit.res` | 1 to 1000000 levels | Unipolar `(0, 1)` <br /> Logarithmic normalization: <br /> -- 100 levels → 0.0 (poor quality), <br /> -- 100000 levels → 0.95 (excellent quality). <br /> Maps number of unique amplitude levels to digital resolution quality - higher values indicate finer quantization resolution. | Number of unique amplitude levels detected in the bandpass-filtered signal with tolerance for floating point precision. Measures the granularity of the digital audio quantization. More unique levels indicate higher resolution and less coarse quantization. | unique amplitude level counting with tolerance: <br /> `signal = signal - np.mean(signal)` <br /> `sorted_signal = np.sort(np.abs(signal[signal != 0]))` <br /> `unique_levels = count_unique_with_tolerance(sorted_signal, tolerance)` <br /> `num_levels = len(unique_levels)`
|`quantization::avg_noise_floor_db`| Quantization Noise Floor (dB) | `noise Q` | -200 to -20 dBFS | Unipolar `(0, 1)` <br /> Inverted sigmoid normalization: <br /> -- -200 dBFS → 0.95 (excellent quality), <br /> -- -20 dBFS → 0.05 (poor quality). <br /> Maps quantization noise floor to audio quality - lower noise floors indicate better quantization quality. | Average noise floor level of the bandpass-filtered signal calculated from FFT spectrum analysis. Measures the background quantization noise level. Lower values indicate less quantization noise and higher digital audio quality. | noise floor estimation from FFT spectrum: <br /> `windowed = frame * np.hanning(frame_size)` <br /> `fft_mag = np.abs(np.fft.fft(windowed))` <br /> `noise_floor = np.percentile(fft_mag, percentile)` <br /> `noise_floor_db = 20 * np.log10(noise_floor)` <br /> `avg_noise_floor_db = np.mean([artifacts['noise_floor_db']])`
|`quantization::noise_floor_std_db`| Noise Floor Stability (dB) | `noise st` | 0 to 40 dB | Unipolar `(0, 1)` <br /> Inverted sigmoid normalization: <br /> -- 0.0 dB → 0.95 (perfect consistency), <br /> -- 20.0 dB → 0.05 (high variability). <br /> Maps noise floor variability to stability quality - lower standard deviation indicates more consistent quantization noise. | Standard deviation of noise floor measurements across all frames in the bandpass-filtered signal. Measures the consistency of quantization noise levels. Lower values indicate stable quantization behavior, higher values suggest variable or problematic quantization. | noise floor standard deviation from FFT analysis: <br /> `windowed = frame * np.hanning(frame_size)` <br /> `fft_mag = np.abs(np.fft.fft(windowed))` <br /> `noise_floor_db = 20 * np.log10(np.percentile(fft_mag, percentile))` <br /> `noise_floor_std_db = np.std([artifacts['noise_floor_db']])`
|`quantization::avg_spectral_slope_db`| Dithering Quality (dB) | `dither Q` | -60 to 20 dB | Bipolar `(-1, 1)` <br /> Sigmoid normalization: <br /> -- -20.0 dB → 0.95 (natural rolloff, good), <br /> -- -5.0 dB → 0.0 (moderate rolloff, neutral), <br /> -- 10.0 dB → -0.95 (flat/boosted highs, poor). <br /> Maps spectral slope to dithering quality - steeper negative slopes indicate better quantization behavior. | Average spectral slope between mid and high frequencies in the bandpass-filtered signal. Measures the high-frequency rolloff characteristics which indicate quantization noise patterns. Steeper negative slopes suggest natural rolloff, flatter slopes indicate quantization artifacts or poor dithering. | spectral slope calculation from FFT analysis: <br /> `windowed = frame * np.hanning(frame_size)` <br /> `fft_mag = np.abs(np.fft.fft(windowed))` <br /> `mid_energy = np.mean(fft_mag[mid_idx:high_idx])` <br /> `high_energy = np.mean(fft_mag[high_idx:])` <br /> `spectral_slope_db = 20 * np.log10(high_energy / mid_energy)` <br /> `avg_spectral_slope_db = np.mean([artifacts['spectral_slope_db']])`
|`quantization::spectral_slope_std_db`| Dithering Stability (dB) | `dither st` | 0 to 30 dB | Unipolar `(0, 1)` <br /> Inverted sigmoid normalization: <br /> -- 0.0 dB → 0.95 (perfect consistency), <br /> -- 15.0 dB → 0.05 (high variability). <br /> Maps spectral slope variability to dithering stability - lower standard deviation indicates more consistent quantization behavior. | Standard deviation of spectral slope measurements across all frames in the bandpass-filtered signal. Measures the consistency of high-frequency rolloff characteristics. Lower values indicate stable quantization behavior, higher values suggest variable or problematic dithering. | spectral slope standard deviation from FFT analysis: <br /> `windowed = frame * np.hanning(frame_size)` <br /> `fft_mag = np.abs(np.fft.fft(windowed))` <br /> `spectral_slope_db = 20 * np.log10(high_energy / mid_energy)` <br /> `spectral_slope_std_db = np.std([artifacts['spectral_slope_db']])`
|`quantization::dynamic_range_db`| Dynamic Range (dB) | `dyn.rng` | 0 to 300 dB | Bipolar `(-1, 1)` <br /> Piecewise sigmoid normalization: <br /> -- 20.0 dB → -0.95 (practical minimum), <br /> -- 110.0 dB → 0.0 (midpoint), <br /> -- 200.0 dB → 0.95 (practical maximum). <br /> Maps dynamic range to audio quality - higher values indicate better separation between signal and noise floor. | Dynamic range of the bandpass-filtered signal calculated as the difference between peak level and average noise floor. Measures the separation between the loudest signal content and the quantization noise floor. Higher values indicate better signal-to-noise ratio and quantization quality. | dynamic range calculation from peak and noise floor: <br /> `peak_level = 20 * np.log10(np.max(np.abs(band_signal)))` <br /> `avg_noise_floor = np.mean([artifacts['noise_floor_db']])` <br /> `dynamic_range_db = peak_level - avg_noise_floor`
|`quantization_full_spectrum::left_estimated_bits` <br /> `quantization_full_spectrum::right_estimated_bits` <br /> `quantization_full_spectrum::mono_estimated_bits`| Estimated Bit Depth | - | 1 to 32 bits | - | Estimated effective bit depth of the full-spectrum signal by analyzing quantization levels. Measures the resolution of the digital audio quantization. Higher bit depths indicate finer amplitude resolution and lower quantization noise. | bit depth estimation from unique amplitude levels: <br /> `signal = signal - np.mean(signal)` <br /> `sorted_signal = np.sort(np.abs(signal[signal != 0]))` <br /> `unique_levels = count_unique_with_tolerance(sorted_signal)` <br /> `estimated_bits = np.log2(num_levels * 2)`
|`quantization_full_spectrum::left_unique_levels` <br /> `quantization_full_spectrum::right_unique_levels` <br /> `quantization_full_spectrum::mono_unique_levels`| Digital Resolution | - | 1 to 1000000 levels | - | Number of unique amplitude levels detected in the full-spectrum signal with tolerance for floating point precision. Measures the granularity of the digital audio quantization. More unique levels indicate higher resolution and less coarse quantization. | unique amplitude level counting with tolerance: <br /> `signal = signal - np.mean(signal)` <br /> `sorted_signal = np.sort(np.abs(signal[signal != 0]))` <br /> `unique_levels = count_unique_with_tolerance(sorted_signal, tolerance)` <br /> `num_levels = len(unique_levels)`
|`quantization_full_spectrum::left_avg_noise_floor_db` <br /> `quantization_full_spectrum::right_avg_noise_floor_db` <br /> `quantization_full_spectrum::mono_avg_noise_floor_db`| Quantization Noise Floor (dB) | - | -200 to -20 dBFS | - | Average noise floor level of the full-spectrum signal calculated from FFT spectrum analysis. Measures the background quantization noise level. Lower values indicate less quantization noise and higher digital audio quality. | noise floor estimation from FFT spectrum: <br /> `windowed = frame * np.hanning(frame_size)` <br /> `fft_mag = np.abs(np.fft.fft(windowed))` <br /> `noise_floor = np.percentile(fft_mag, percentile)` <br /> `noise_floor_db = 20 * np.log10(noise_floor)` <br /> `avg_noise_floor_db = np.mean([artifacts['noise_floor_db']])`
|`quantization_full_spectrum::left_noise_floor_std_db` <br /> `quantization_full_spectrum::right_noise_floor_std_db` <br /> `quantization_full_spectrum::mono_noise_floor_std_db`| Noise Floor Stability (dB) | - | 0 to 40 dB | - | Standard deviation of noise floor measurements across all frames in the full-spectrum signal. Measures the consistency of quantization noise levels. Lower values indicate stable quantization behavior, higher values suggest variable or problematic quantization. | noise floor standard deviation from FFT analysis: <br /> `windowed = frame * np.hanning(frame_size)` <br /> `fft_mag = np.abs(np.fft.fft(windowed))` <br /> `noise_floor_db = 20 * np.log10(np.percentile(fft_mag, percentile))` <br /> `noise_floor_std_db = np.std([artifacts['noise_floor_db']])`
|`quantization_full_spectrum::left_avg_spectral_slope_db` <br /> `quantization_full_spectrum::right_avg_spectral_slope_db` <br /> `quantization_full_spectrum::mono_avg_spectral_slope_db`| Dithering Quality (dB) | - | -60 to 20 dB | - | Average spectral slope between mid and high frequencies in the full-spectrum signal. Measures the high-frequency rolloff characteristics which indicate quantization noise patterns. Steeper negative slopes suggest natural rolloff, flatter slopes indicate quantization artifacts or poor dithering. | spectral slope calculation from FFT analysis: <br /> `windowed = frame * np.hanning(frame_size)` <br /> `fft_mag = np.abs(np.fft.fft(windowed))` <br /> `mid_energy = np.mean(fft_mag[mid_idx:high_idx])` <br /> `high_energy = np.mean(fft_mag[high_idx:])` <br /> `spectral_slope_db = 20 * np.log10(high_energy / mid_energy)` <br /> `avg_spectral_slope_db = np.mean([artifacts['spectral_slope_db']])`
|`quantization_full_spectrum::left_spectral_slope_std_db` <br /> `quantization_full_spectrum::right_spectral_slope_std_db` <br /> `quantization_full_spectrum::mono_spectral_slope_std_db`| Dithering Stability (dB) | - | 0 to 30 dB | - | Standard deviation of spectral slope measurements across all frames in the full-spectrum signal. Measures the consistency of high-frequency rolloff characteristics. Lower values indicate stable quantization behavior, higher values suggest variable or problematic dithering. | spectral slope standard deviation from FFT analysis: <br /> `windowed = frame * np.hanning(frame_size)` <br /> `fft_mag = np.abs(np.fft.fft(windowed))` <br /> `spectral_slope_db = 20 * np.log10(high_energy / mid_energy)` <br /> `spectral_slope_std_db = np.std([artifacts['spectral_slope_db']])`
|`quantization_full_spectrum::left_dynamic_range_db` <br /> `quantization_full_spectrum::right_dynamic_range_db` <br /> `quantization_full_spectrum::mono_dynamic_range_db`| Dynamic Range (dB) | - | 0 to 300 dB | - | Dynamic range of the full-spectrum signal calculated as the difference between peak level and average noise floor. Measures the separation between the loudest signal content and the quantization noise floor. Higher values indicate better signal-to-noise ratio and quantization quality. | dynamic range calculation from peak and noise floor: <br /> `peak_level = 20 * np.log10(np.max(np.abs(signal)))` <br /> `avg_noise_floor = np.mean([artifacts['noise_floor_db']])` <br /> `dynamic_range_db = peak_level - avg_noise_floor`

#### `sparkle`

|key|title|label|def. range|norm. fn|description|algo (py)
|--|--|--|--|--|--|--
|`sparkle::sparkle`| Sparkle | `sparkle` | 0.0 to 2.0 | Unipolar `(0, 1)` <br /> Hybrid normalization: <br /> -- Linear up to 0.3 → 0.95, <br /> -- Exponential above 0.3 → 1.0. <br /> Maps high-frequency transient energy to sparkle perception - higher values indicate more high-frequency detail and brightness. | RMS energy of transients in the bandpass-filtered signal with bandwidth compensation. Measures high-frequency content and transient detail. Set to 0.0 for bands below 2kHz threshold. Higher values indicate more sparkle and high-frequency energy. | transient RMS calculation with bandwidth compensation: <br /> `frame = signal[i:i+frame_size]` <br /> `rms = np.sqrt(np.mean(np.square(frame)))` <br /> `sparkle_value = np.mean(frame_energy)` <br /> `band_octaves = np.log2(f_high / f_low)` <br /> `compensation_factor = total_octaves / band_octaves` <br /> `sparkle_compensated = sparkle_value * compensation_factor`

#### `stereo_correlation`, `stereo_phase`, `stereo_width`

|key|title|label|def. range|norm. fn|description|algo (py)
|--|--|--|--|--|--|--
|`stereo_correlation::correlation`| Stereo Correlation | `st.corr` | -1.0 to 1.0 | Bipolar `(-1, 1)` <br /> Linear clipping normalization: <br /> -- -1.0 → -1.0 (anti-correlated), <br /> -- 0.0 → 0.0 (uncorrelated), <br /> -- 1.0 → 1.0 (perfectly correlated). <br /> Maps linear relationship between stereo channels - values indicate amplitude correlation between left and right channels. | Correlation coefficient between left and right channels in the bandpass-filtered signal. Measures the similarity between stereo channels within the frequency band. Values near 1.0 indicate highly correlated (mono-like) content, values near 0.0 indicate uncorrelated content, and values near -1.0 indicate anti-correlated content. | stereo correlation calculation using Pearson correlation: <br /> `left_band = bandpass(left, rate, f_low, f_high)` <br /> `right_band = bandpass(right, rate, f_low, f_high)` <br /> `correlation = np.corrcoef(left_band, right_band)[0, 1]`
|`stereo_phase::coherence`| Stereo Phase Coherence | `st.phase` | -1.0 to 1.0 | Bipolar `(-1, 1)` <br /> Linear clipping normalization: <br /> -- -1.0 → -1.0 (perfect anti-phase), <br /> -- 0.0 → 0.0 (random phases), <br /> -- +1.0 → +1.0 (perfect in-phase). <br /> Maps phase relationship between stereo channels - values indicate degree of phase alignment across frequency spectrum. | Phase coherence between left and right channels in the bandpass-filtered signal using windowed FFT phase analysis. Measures energy-weighted phase alignment of stereo channels within the frequency band. Values near +1.0 indicate strong in-phase coherence (mono-like content), values near 0.0 indicate random phase relationships (wide stereo content), values near -1.0 indicate anti-phase relationships (mono cancellation risk). **Note: Slower analysis due to FFT processing with overlapping windows.** | Energy-weighted phase coherence calculation using overlapping FFT windows: <br /> `left_fft = np.fft.fft(left_windowed)` <br /> `right_fft = np.fft.fft(right_windowed)` <br /> `phase_diff = np.angle(left_fft) - np.angle(right_fft)` <br /> `weights = (left_mag² + right_mag²) / sum(energies)` <br /> `coherence = np.average(np.cos(phase_diff), weights=weights)` <br /> Averaged across overlapping time windows (75% overlap by default)
|`stereo_width::mid_rms`| Mid Channel RMS (dBFS) | - | -96 to 0 dBFS | - | RMS level of the mid (sum) component in the bandpass-filtered signal. Calculated as the average of left and right channels, representing the mono/center content within the frequency band. Higher values indicate stronger center-positioned content. | mid/side processing and RMS calculation: <br /> `left_band = bandpass(left, rate, f_low, f_high)` <br /> `right_band = bandpass(right, rate, f_low, f_high)` <br /> `mid = 0.5 * (left_band + right_band)` <br /> `mid_rms = 20 * np.log10(np.sqrt(np.mean(mid ** 2)))`
|`stereo_width::side_rms`| Side Channel RMS (dBFS) | - | -96 to 0 dBFS | - | RMS level of the side (difference) component in the bandpass-filtered signal. Calculated as the difference of left and right channels, representing the stereo/width content within the frequency band. Higher values indicate stronger stereo width and spatial information. | mid/side processing and RMS calculation: <br /> `left_band = bandpass(left, rate, f_low, f_high)` <br /> `right_band = bandpass(right, rate, f_low, f_high)` <br /> `side = 0.5 * (left_band - right_band)` <br /> `side_rms = 20 * np.log10(np.sqrt(np.mean(side ** 2)))`
|`stereo_width::width_ratio`| Stereo Width Ratio | drawn as `st.presence`, `st.natrl` | 0.0 to ∞ | - | Ratio of side channel amplitude to mid channel amplitude in the bandpass-filtered signal. Measures stereo width within the frequency band. Lower values indicate mono-like content, higher values indicate wider stereo image. <br /> <br /> Visualized by component via `stereo_width::presence` and `stereo_width::quality` | mid/side amplitude ratio calculation: <br /> `mid = 0.5 * (left_band + right_band)` <br /> `side = 0.5 * (left_band - right_band)` <br /> `width_ratio = 10^(side_rms/20) / 10^(mid_rms/20)`
|`stereo_width::presence`| Stereo Presence | `st.presence` | 0.0 to 1.0 | Unipolar `(0, 1)` <br /> Linear clipping normalization: <br /> -- 0.0 → 0.0 (no stereo presence), <br /> -- 1.0 → 1.0 (full stereo presence). <br /> Maps stereo width to presence perception using exponential saturation curve. | Stereo presence derived from width ratio using exponential approach to saturation. Measures the perceived stereo width within the frequency band. Values approach 1.0 asymptotically as width increases, representing diminishing returns of very wide stereo content. <br /> <br /> A visualization component of `stereo_width::width_ratio`. | exponential presence calculation from width ratio: <br /> `width_ratio = side_amplitude / mid_amplitude` <br /> `presence = 1 - np.exp(-width_ratio * 2.0 / 2.0)` <br /> `presence = 1 - np.exp(-width_ratio)`
|`stereo_width::quality`| Stereo Naturalness | `st.natrl` | -1.0 to 1.0 | Bipolar `(-1, 1)` <br /> Linear clipping normalization: <br /> -- -1.0 → -1.0 (completely broken), <br /> -- 0.0 → 0.0 (poor quality), <br /> -- 1.0 → 1.0 (perfect quality). <br /> Maps stereo width to naturalness perception using piecewise quality function. | Stereo quality derived from width ratio using piecewise function. Measures the naturalness of stereo width within the frequency band. Values above 0 indicate natural stereo, values below 0 indicate problematic phase or width issues. <br /> <br /> A visualization component of `stereo_width::width_ratio`. | piecewise quality calculation from width ratio: <br /> `if width_ratio < 1.0: quality = 1.0` <br /> `elif width_ratio <= 2.0: quality = 1.0 - (width_ratio - 1.0)` <br /> `elif width_ratio <= 2.3: quality = -0.95 * (width_ratio - 2.0) / 0.3` <br /> `else: quality = -1.0`

#### `audio_quality`

|key|title|label|def. range|norm. fn|description|algo (py)
|--|--|--|--|--|--|--
|`audio_quality::quantization_efficiency`| Quantization Efficiency | `dither.effy` | 0.0 to 1.0+ | Unipolar `(0, 1)` <br /> Triangular normalization: <br /> -- ≤0.25 → 0.0 (underused quantization), <br /> -- 0.575 → 1.0 (natural utilization), <br /> -- ≥0.85 → 0.0 (overused quantization). <br /> Maps ratio of actual to theoretical quantization levels with quality declining away from natural point. Lower values indicate underutilized quantization, higher values indicate overutilized/artificial quantization. | Efficiency ratio of actual unique amplitude levels to theoretical levels based on estimated bit depth. Measures quantization utilization within the frequency band. Values around 0.575 represent natural audio characteristics, while deviation in either direction suggests quality issues - underutilization (too few levels used) or overutilization (unnaturally high level usage). Note: 0.575 as optimal point is an assumption based on typical natural audio behavior. | quantization efficiency calculation: <br /> `theoretical_levels = 2 ** estimated_bits` <br /> `quantization_efficiency = unique_levels / theoretical_levels`
|`audio_quality::spectral_flatness_ratio`| Overall Musicality | `ovrl.mus` | 0.0 to 1.0 | Bipolar `(-1, 1)` <br /> Musical center normalization: <br /> -- 0.3-0.5 → 0.95 (musical sweet spot), <br /> -- 0.4 → 0.95 (optimal musicality), <br /> -- 0.0 or 1.0 → -0.95 (extreme penalty). <br /> Maps spectral flatness to musicality with quality declining away from natural musical range. Values in sweet spot indicate musical content, extreme values indicate pure tones or noise. | Spectral flatness ratio of the full-spectrum signal (all bands have the same value, that ot the full-spectrum analysis) measuring overall musicality. Represents the balance between tonal and noise-like characteristics across the entire frequency range. Values around 0.4 indicate optimal musical content, while values near 0.0 (pure tones) or 1.0 (pure noise) receive negative scores. | spectral flatness ratio from full-spectrum analysis: <br /> `spectral_flatness_ratio = geometric_mean / arithmetic_mean` <br /> `flatness_ratio = geo_mean / arith_mean` <br /> (from harmonics_full_spectrum analysis)
|`audio_quality::avg_sinad_db`| Average SINAD (dB) | `SINAD` | 0 to 120 dB | Unipolar `(0, 1)` <br /> Sigmoid normalization: <br /> -- 40.0 dB → 0.05 (poor quality), <br /> -- 70.0 dB → 0.95 (high-end audio). <br /> Maps signal-to-noise-and-distortion ratio to audio quality - higher values indicate cleaner signal with less noise and distortion. | Average signal-to-noise-and-distortion ratio of the full-spectrum signal (all bands have the same value, that ot the full-spectrum analysis) calculated from FFT frame analysis. Measures the ratio of total signal energy to noise floor energy across all frequency bins. Higher values indicate better signal quality with lower noise and distortion levels. | SINAD calculation from FFT spectrum analysis: <br /> `windowed = frame * np.hanning(fft_size)` <br /> `fft_mag = np.abs(np.fft.rfft(windowed))` <br /> `total_energy = np.sum(fft_mag ** 2)` <br /> `noise_energy = (noise_floor_mag ** 2) * len(fft_mag)` <br /> `sinad_db = 10 * np.log10(total_energy / noise_energy)` <br /> `avg_sinad_db = np.mean([frame_sinads])`
|`audio_quality::min_sinad_db`| Minimum SINAD (dB) | - | 0 to 120 dB | - | Minimum signal-to-noise-and-distortion ratio across all analyzed frames in the full-spectrum signal (all bands have the same value, that ot the full-spectrum analysis). Represents the worst-case SINAD measurement within the chunk, indicating periods of highest noise or distortion. Lower values suggest problematic segments with poor signal quality. | SINAD minimum calculation from FFT frame analysis: <br /> `windowed = frame * np.hanning(fft_size)` <br /> `fft_mag = np.abs(np.fft.rfft(windowed))` <br /> `total_energy = np.sum(fft_mag ** 2)` <br /> `noise_energy = (noise_floor_mag ** 2) * len(fft_mag)` <br /> `sinad_db = 10 * np.log10(total_energy / noise_energy)` <br /> `min_sinad_db = np.min([frame_sinads])`
|`audio_quality::max_sinad_db`| Maximum SINAD (dB) | - | 0 to 120 dB | - | Maximum signal-to-noise-and-distortion ratio across all analyzed frames in the full-spectrum signal (all bands have the same value, that ot the full-spectrum analysis). Represents the best-case SINAD measurement within the chunk, indicating periods of lowest noise and distortion. Higher values suggest optimal signal quality segments. | SINAD maximum calculation from FFT frame analysis: <br /> `windowed = frame * np.hanning(fft_size)` <br /> `fft_mag = np.abs(np.fft.rfft(windowed))` <br /> `total_energy = np.sum(fft_mag ** 2)` <br /> `noise_energy = (noise_floor_mag ** 2) * len(fft_mag)` <br /> `sinad_db = 10 * np.log10(total_energy / noise_energy)` <br /> `min_sinad_db = np.max([frame_sinads])`
|`audio_quality::std_sinad_db`| SINAD Stability (dB) | `SINAD.stab` | 0 to 30 dB | Bipolar `(-1, 1)` <br /> Inverted sigmoid normalization: <br /> -- 0.0 dB → 0.95 (perfect stability), <br /> -- 8.0 dB → 0.0 (neutral stability), <br /> -- 16.0 dB → -0.95 (very poor stability). <br /> Maps SINAD variation to stability quality - lower standard deviation indicates more consistent signal quality. | Standard deviation of signal-to-noise-and-distortion ratio across all analyzed frames in the full-spectrum signal (all bands have the same value, that ot the full-spectrum analysis). Measures the consistency of signal quality within the chunk. Lower values indicate stable signal quality, higher values suggest varying noise/distortion levels. | SINAD standard deviation calculation from FFT frame analysis: <br /> `windowed = frame * np.hanning(fft_size)` <br /> `fft_mag = np.abs(np.fft.rfft(windowed))` <br /> `total_energy = np.sum(fft_mag ** 2)` <br /> `noise_energy = (noise_floor_mag ** 2) * len(fft_mag)` <br /> `sinad_db = 10 * np.log10(total_energy / noise_energy)` <br /> `std_sinad_db = np.std([frame_sinads])`

#### `dynamic_range`

|key|title|label|def. range|norm. fn|description|algo (py)
|--|--|--|--|--|--|--
|`dynamic_range::peak_to_noise_ratio_db`| Peak-to-Noise Ratio (dB) | `dyn.PTNR` | 0 to 300 dB | Bipolar `(-1, 1)` <br /> Sigmoid normalization: <br /> -- 40.0 dB → -0.95 (poor quality), <br /> -- 120.0 dB → 0.0 (neutral quality), <br /> -- 200.0 dB → 0.95 (excellent quality). <br /> Maps peak-to-noise ratio to dynamic range quality - higher values indicate better separation between signal peaks and noise floor. | Peak-to-noise ratio calculated as the difference between bandpass-filtered signal peak level and quantization noise floor. Measures the dynamic range between the loudest signal content and the noise floor within the frequency band. Higher values indicate better signal-to-noise performance and lower noise floor. | peak-to-noise ratio calculation: <br /> `peak_dbfs = dynamics_peak_level` <br /> `noise_floor_db = quantization_avg_noise_floor_db` <br /> `peak_to_noise_ratio_db = peak_dbfs - noise_floor_db`
|`dynamic_range::signal_to_noise_ratio_db`| Signal-to-Noise Ratio (dB) | `dyn.STNR` | 0 to 200 dB | Bipolar `(-1, 1)` <br /> Sigmoid normalization: <br /> -- 20.0 dB → -0.95 (poor quality), <br /> -- 100.0 dB → 0.0 (neutral quality), <br /> -- 180.0 dB → 0.95 (excellent quality). <br /> Maps signal-to-noise ratio to dynamic range quality - higher values indicate better separation between average signal level and noise floor. | Signal-to-noise ratio calculated as the difference between bandpass-filtered signal RMS level and quantization noise floor. Measures the dynamic range between the average signal content and the noise floor within the frequency band. Higher values indicate better signal-to-noise performance and cleaner audio quality. | signal-to-noise ratio calculation: <br /> `rms_dbfs = dynamics_rms_level` <br /> `noise_floor_db = quantization_avg_noise_floor_db` <br /> `signal_to_noise_ratio_db = rms_dbfs - noise_floor_db`
|`dynamic_range::overall_avg_crest_factor_db`| Overall Average Crest Factor (dB) | `ovrl.dyn` | 0 to 30 dB | Bipolar `(-1, 1)` <br /> Sigmoid normalization: <br /> -- 3.0 dB → -0.95 (heavily compressed), <br /> -- 8.0 dB → 0.0 (neutral dynamics), <br /> -- 16.0 dB → 0.95 (natural dynamics). <br /> Maps overall crest factor to dynamic range quality - higher values indicate more natural, less compressed audio. | Overall average crest factor of the full-spectrum signal (all bands have the same value, that ot the full-spectrum analysis) representing the global dynamic character. Measures the average peak-to-RMS ratio across all frames in the entire frequency spectrum. Higher values indicate more natural dynamics, lower values suggest compression or limiting. | overall crest factor from full-spectrum dynamics analysis: <br /> `overall_avg_crest_factor_db = dynamics_full_spectrum_avg_crest_factor_db`

