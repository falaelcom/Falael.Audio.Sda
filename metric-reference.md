# Falael.Audio.Sda

A multi-band audio analysis system that extracts technical and perceptual metrics (dynamics, frequency response, harmonics, quantization, stereo imaging) from audio files, outputting a fingerprint in the form of a structured JSON data and charts for comprehensive audio quality assessment and comparison.

### Basics

Audio files are split into 30s chunks and the full spectrum is split into 10 logarithmic bands:

|Band|Description
|--|-- 
| `   20 -    40 Hz` | Sub-bass (felt more than heard, rumble, kick drum fundamentals)
| `   40 -    80 Hz` | Bass fundamentals (bass guitar, kick drum body, low piano notes)
| `   80 -   161 Hz` | Upper bass (bass guitar harmonics, male vocal fundamentals, low brass)
| `  161 -   323 Hz` | Low midrange (vocal fundamentals, guitar body, snare drum body)
| `  323 -   648 Hz` | Lower midrange (vocal clarity, guitar warmth, piano middle register)
| `  648 -  1299 Hz` | Midrange (vocal presence, guitar definition, brass instruments)
| ` 1299 -  2605 Hz` | Upper midrange (vocal intelligibility, guitar attack, brass brightness)
| ` 2605 -  5223 Hz` | Presence (vocal sibilance, cymbal attack, instrument clarity)
| ` 5223 - 10473 Hz` | Brilliance (cymbal shimmer, vocal air, string instrument harmonics)
| `10473 - 21000 Hz` | Air/sparkle (extreme highs, cymbal sizzle, spatial information)

All metrics are calculated per (band, chunk) pair, unless explicitly specified otherwise, in which case the same full-spectrum value is provided for all bands.

Per-band metrics are performed on signal that is that bandpass-filtered 4th-order Butterworth filter:

`py/x2/lib/bandpass_filter.py`
```python
def bandpass(data, rate, low, high):
    nyq = 0.5 * rate
    if high / nyq >= 1.0 or low / nyq <= 0: raise ValueError("Digital filter critical frequencies must be 0 < Wn < 1")
    sos = scipy.signal.butter(4, [low / nyq, high / nyq], btype='band', output='sos')
    return scipy.signal.sosfilt(sos, data)
```

Only metrics that appear in fingerprint images have a label and a normalization function specified. A list of all metrics is available after the __Image-Only Metrics__.

Metrics for the last track chunk might be distorted as all metrics are optimized for 30s chunk processing, and the last chunk is usually much shorter. For very short chunks, some metrics don't have meaning and a default value .

#### Normalization

Definition ranges of all metrics that appear in charts are normalized either to unipolar `(0, 1)` or bipolar `(-1, 1)` normalized ranges. Metrics are plotted as follows 

- Unipolar `(0, 1)` - 1 as primary color, 0 as gray;
- Bipolar `(-1, 1)` - 1 as primary color, 0 as saturated gray, -1 as complementary color;

where data point primary and complementary colors are generated automatically across the full color spectrum (primary colors span half spectrum and complementary colors span naturally the other half of the spectrum).

Normalization functions have been designed to match the default configuration of chunk (30s per chunk) and band (10 bands from 20Hz to 21kHz) splitting. If these values change, normalization functions will most likely need adjustment.

### Image-Only Metrics (in order of appearance in charts)

|key|title|label|def. range|norm. fn|description|algo (py)
|--|--|--|--|--|--|--
|`stereo_width::presence`| Stereo Presence | `st.presence` | 0.0 to 1.0 | Unipolar `(0, 1)` <br /> Linear clipping normalization: <br /> -- 0.0 → 0.0 (no stereo presence), <br /> -- 1.0 → 1.0 (full stereo presence). <br /> Maps stereo width to presence perception using exponential saturation curve. | Stereo presence derived from width ratio using exponential approach to saturation. Measures the perceived stereo width within the frequency band. Values approach 1.0 asymptotically as width increases, representing diminishing returns of very wide stereo content. <br /> <br /> A visualization component of `stereo_width::width_ratio`. | exponential presence calculation from width ratio: <br /> `width_ratio = side_amplitude / mid_amplitude` <br /> `presence = 1 - np.exp(-width_ratio * 2.0 / 2.0)` <br /> `presence = 1 - np.exp(-width_ratio)`
|`stereo_width::quality`| Stereo Naturalness | `st.natrl` | -1.0 to 1.0 | Bipolar `(-1, 1)` <br /> Linear clipping normalization: <br /> -- -1.0 → -1.0 (completely broken), <br /> -- 0.0 → 0.0 (poor quality), <br /> -- 1.0 → 1.0 (perfect quality). <br /> Maps stereo width to naturalness perception using piecewise quality function. | Stereo quality derived from width ratio using piecewise function. Measures the naturalness of stereo width within the frequency band. Values above 0 indicate natural stereo, values below 0 indicate problematic phase or width issues. <br /> <br /> A visualization component of `stereo_width::width_ratio`. | piecewise quality calculation from width ratio: <br /> `if width_ratio < 0.85: quality = 1.0` <br /> `elif width_ratio <= 1.0: quality = 1.0 - (width_ratio - 0.85) / 0.15` <br /> `elif width_ratio <= 1.3: quality = -0.7 * (width_ratio - 1.0) / 0.3` <br /> `else: quality = -1.0`
|`stereo_correlation::correlation`| Stereo Correlation | `st.corr` | -1.0 to 1.0 | Bipolar `(-1, 1)` <br /> Linear clipping normalization: <br /> -- -1.0 → -1.0 (anti-correlated), <br /> -- 0.0 → 0.0 (uncorrelated), <br /> -- 1.0 → 1.0 (perfectly correlated). <br /> Maps linear relationship between stereo channels - values indicate amplitude correlation between left and right channels. | Correlation coefficient between left and right channels in the bandpass-filtered signal. Measures the similarity between stereo channels within the frequency band. Values near 1.0 indicate highly correlated (mono-like) content, values near 0.0 indicate uncorrelated content, and values near -1.0 indicate anti-correlated content. | stereo correlation calculation using Pearson correlation: <br /> `left_band = bandpass(left, rate, f_low, f_high)` <br /> `right_band = bandpass(right, rate, f_low, f_high)` <br /> `correlation = np.corrcoef(left_band, right_band)[0, 1]`
|`stereo_phase::coherence`| Stereo Phase Coherence | `st.phase` | -1.0 to 1.0 | Bipolar `(-1, 1)` <br /> Linear clipping normalization: <br /> -- -1.0 → -1.0 (perfect anti-phase), <br /> -- 0.0 → 0.0 (random phases), <br /> -- +1.0 → +1.0 (perfect in-phase). <br /> Maps phase relationship between stereo channels - values indicate degree of phase alignment across frequency spectrum. | Phase coherence between left and right channels in the bandpass-filtered signal using windowed FFT phase analysis. Measures energy-weighted phase alignment of stereo channels within the frequency band. Values near +1.0 indicate strong in-phase coherence (mono-like content), values near 0.0 indicate random phase relationships (wide stereo content), values near -1.0 indicate anti-phase relationships (mono cancellation risk). **Note: Slower analysis due to FFT processing with overlapping windows.** | Energy-weighted phase coherence calculation using overlapping FFT windows: <br /> `left_fft = np.fft.fft(left_windowed)` <br /> `right_fft = np.fft.fft(right_windowed)` <br /> `phase_diff = np.angle(left_fft) - np.angle(right_fft)` <br /> `weights = (left_mag² + right_mag²) / sum(energies)` <br /> `coherence = np.average(np.cos(phase_diff), weights=weights)` <br /> Averaged across overlapping time windows (75% overlap by default)
|`sparkle::sparkle`| Sparkle | `sparkle` | 0.0 to 2.0 | Unipolar `(0, 1)` <br /> Hybrid normalization: <br /> -- Linear up to 0.3 → 0.95, <br /> -- Exponential above 0.3 → 1.0. <br /> Maps high-frequency transient energy to sparkle perception - higher values indicate more high-frequency detail and brightness. | RMS energy of transients in the bandpass-filtered signal with bandwidth compensation. Measures high-frequency content and transient detail. Set to 0.0 for bands below 2kHz threshold. Higher values indicate more sparkle and high-frequency energy. | transient RMS calculation with bandwidth compensation: <br /> `frame = signal[i:i+frame_size]` <br /> `rms = np.sqrt(np.mean(np.square(frame)))` <br /> `sparkle_value = np.mean(frame_energy)` <br /> `band_octaves = np.log2(f_high / f_low)` <br /> `compensation_factor = total_octaves / band_octaves` <br /> `sparkle_compensated = sparkle_value * compensation_factor`
|`harmonics::spectral_centroid_fraction`| Spectral Centroid Fraction | `brightness` | 0.0 to 1.0 | Unipolar `(0, 1)` <br /> Simple clipping: <br /> -- 0.0 → warmer (energy at bottom of band), <br /> -- 1.0 → brighter (energy at top of band). <br /> Normalized position of spectral centroid within each frequency band. | Spectral centroid (center of mass of frequency spectrum) calculated within each bandpass-filtered frequency band and normalized to 0-1 range relative to band boundaries. Measures brightness/warmth characteristics within specific frequency ranges. 0.0 indicates energy concentrated at lower frequencies of the band (warmer), 1.0 indicates energy concentrated at higher frequencies of the band (brighter). | Per-band spectral centroid analysis using overlapping FFT frames: <br /> `band_signal = bandpass(data, rate, f_low, f_high)` <br /> `windowed = frame * np.hanning(fft_size)` <br /> `fft = np.fft.rfft(windowed)` <br /> `frequencies = np.fft.rfftfreq(fft_size, 1/sample_rate)` <br /> `band_mask = (frequencies >= f_low) & (frequencies <= f_high)` <br /> `centroid = np.sum(band_freqs * band_mags) / np.sum(band_mags)` <br /> `centroid_fraction = (centroid - f_low) / (f_high - f_low)`
|`harmonics::spectral_rolloff_fraction`| Spectral Rolloff Fraction | `fullness` | 0.0 to 1.0 | Unipolar `(0, 1)` <br /> Simple clipping: <br /> -- 0.0 → concentrated (energy in lower part of band), <br /> -- 1.0 → full spectrum (energy spread throughout band). <br /> Normalized position of 85% energy rolloff point within each frequency band. | Spectral rolloff point (frequency below which 85% of energy is contained) calculated within each bandpass-filtered frequency band and normalized to 0-1 range relative to band boundaries. Measures energy distribution characteristics within specific frequency ranges. 0.0 indicates concentrated energy in lower part of band, 1.0 indicates energy spread throughout the entire band. | Per-band spectral rolloff analysis using overlapping FFT frames: <br /> `band_signal = bandpass(data, rate, f_low, f_high)` <br /> `windowed = frame * np.hanning(fft_size)` <br /> `fft = np.fft.rfft(windowed)` <br /> `band_mask = (frequencies >= f_low) & (frequencies <= f_high)` <br /> `cumulative = np.cumsum(band_mags**2)` <br /> `rolloff_idx = np.where(cumulative >= 0.85 * cumulative[-1])[0][0]` <br /> `rolloff_freq = band_freqs[rolloff_idx]` <br /> `rolloff_fraction = (rolloff_freq - f_low) / (f_high - f_low)`
|`freq_response::avg_magnitude_db`| Relative Frequency Balance (dB) | `energy` | -60 to 30 dB | Bipolar `(-1, 1)` <br /> Sigmoid normalization: <br /> -- -3 dB → 0.0 (neutral), <br /> -- -30 dB → -0.95 (low extreme), <br /> -- 10 dB → 0.95 (high extreme). <br /> Maps frequency balance relative to uniform distribution. | Relative energy density of the frequency band compared to uniform distribution across the 20 Hz to 21,000 Hz analysis range. Calculated using overlapping FFT frames with Hanning window. Positive values indicate the band is louder than average, negative values indicate it's quieter than average. | FFT-based frequency analysis with overlapping frames: <br /> `windowed = frame * np.hanning(fft_size)` <br /> `fft_mag = np.abs(np.fft.rfft(windowed))` <br /> `avg_fft = np.mean(frames_ffts, axis=0)` <br /> `band_energy_density = band_energy / band_width` <br /> `balance_db = 20 * np.log10(band_energy_density / expected_energy_density)`
|`audio_quality::overall_spectral_flatness_ratio`| Overall Musicality | `ovrl.mus` | 0.0 to 1.0 | Bipolar `(-1, 1)` <br /> Musical center normalization: <br /> -- 0.3-0.5 → 0.95 (musical sweet spot), <br /> -- 0.4 → 0.95 (optimal musicality), <br /> -- 0.0 or 1.0 → -0.95 (extreme penalty). <br /> Maps spectral flatness to musicality with quality declining away from natural musical range. Values in sweet spot indicate musical content, extreme values indicate pure tones or noise. | Spectral flatness ratio of the full-spectrum signal (all bands have the same value, that ot the full-spectrum analysis) measuring overall musicality. Represents the balance between tonal and noise-like characteristics across the entire frequency range. Values around 0.4 indicate optimal musical content, while values near 0.0 (pure tones) or 1.0 (pure noise) receive negative scores. | spectral flatness ratio from full-spectrum analysis: <br /> `overall_spectral_flatness_ratio = geometric_mean / arithmetic_mean` <br /> `flatness_ratio = geo_mean / arith_mean` <br /> (from harmonics_full_spectrum analysis)
|`audio_quality::std_overall_spectral_flatness_ratio`| Spectral Consistency | `ovrl.var` | 0.0 to 0.25 | Unipolar `(0, 1)` <br /> Consistency normalization: <br /> -- 0.0 → 0.95 (perfect consistency), <br /> -- 0.125 → ~0.5 (moderate variation), <br /> -- 0.25+ → 0.05 (excessive variation). <br /> Lower values indicate more consistent spectral character throughout the audio, higher values indicate high dynamic variation or potential mixing inconsistencies. | Standard deviation of spectral flatness across time frames (all bands have the same value from full-spectrum analysis) measuring spectral consistency. Represents how much the balance between tonal and noise-like characteristics varies over time. Low values indicate consistent spectral character, while high values may indicate very dynamic arrangements or inconsistent processing. | Standard deviation of spectral flatness values from full-spectrum analysis: <br /> `std_spectral_flatness = std(flatness_values_over_time)` <br /> where each flatness value = `geometric_mean / arithmetic_mean` <br /> (from harmonics_full_spectrum analysis)
|`dynamic_range::overall_avg_crest_factor_db`| Overall Average Crest Factor (dB) | `ovrl.dyn` | 0 to 30 dB | Bipolar `(-1, 1)` <br /> Sigmoid normalization: <br /> -- 3.0 dB → -0.95 (heavily compressed), <br /> -- 8.0 dB → 0.0 (neutral dynamics), <br /> -- 16.0 dB → 0.95 (natural dynamics). <br /> Maps overall crest factor to dynamic range quality - higher values indicate more natural, less compressed audio. | Overall average crest factor of the full-spectrum signal (all bands have the same value, that ot the full-spectrum analysis) representing the global dynamic character. Measures the average peak-to-RMS ratio across all frames in the entire frequency spectrum. Higher values indicate more natural dynamics, lower values suggest compression or limiting. | overall crest factor from full-spectrum dynamics analysis: <br /> `overall_avg_crest_factor_db = dynamics_full_spectrum_avg_crest_factor_db`
|`dynamic_range::overall_std_crest_factor_db`| Overall Standard Deviation Crest Factor (dB) | `ovrl.dyn.var` | 0 to 4 dB | Bipolar `(-1, 1)` <br /> Sigmoid normalization: <br /> -- 0.0 dB → -0.95 (overly uniform), <br /> -- 2.0 dB → 0.0 (neutral consistency), <br /> -- 4.0 dB → 0.95 (high variability). <br /> Maps crest factor variability to dynamic consistency - higher values indicate more variable dynamics across frames. | Overall standard deviation of crest factor of the full-spectrum signal (all bands have the same value, that of the full-spectrum analysis) representing the global dynamic variability. Measures the consistency of peak-to-RMS ratios across all frames in the entire frequency spectrum. Higher values indicate more variable dynamics between frames, lower values suggest consistent processing or uniform material. | overall crest factor standard deviation from full-spectrum dynamics analysis: <br /> `overall_std_crest_factor_db = dynamics_full_spectrum_std_crest_factor_db`
|`audio_quality::quantization_efficiency`| Quantization Efficiency | `dither.effy` | 0.0 to 1.0+ | Unipolar `(0, 1)` <br /> Triangular normalization: <br /> -- ≤0.25 → 0.0 (underused quantization), <br /> -- 0.575 → 1.0 (natural utilization), <br /> -- ≥0.85 → 0.0 (overused quantization). <br /> Maps ratio of actual to theoretical quantization levels with quality declining away from natural point. Lower values indicate underutilized quantization, higher values indicate overutilized/artificial quantization. | Efficiency ratio of actual unique amplitude levels to theoretical levels based on estimated bit depth. Measures quantization utilization within the frequency band. Values around 0.575 represent natural audio characteristics, while deviation in either direction suggests quality issues - underutilization (too few levels used) or overutilization (unnaturally high level usage). Note: 0.575 as optimal point is an assumption based on typical natural audio behavior. | quantization efficiency calculation: <br /> `theoretical_levels = 2 ** estimated_bits` <br /> `quantization_efficiency = unique_levels / theoretical_levels`
|`quantization::avg_spectral_slope_db`| Dithering Quality (dB) | `dither Q` | -60 to 20 dB | Bipolar `(-1, 1)` <br /> Sigmoid normalization: <br /> -- -20.0 dB → 0.95 (natural rolloff, good), <br /> -- -5.0 dB → 0.0 (moderate rolloff, neutral), <br /> -- 10.0 dB → -0.95 (flat/boosted highs, poor). <br /> Maps spectral slope to dithering quality - steeper negative slopes indicate better quantization behavior. | Average spectral slope between mid and high frequencies in the bandpass-filtered signal. Measures the high-frequency rolloff characteristics which indicate quantization noise patterns. Steeper negative slopes suggest natural rolloff, flatter slopes indicate quantization artifacts or poor dithering. | spectral slope calculation from FFT analysis: <br /> `windowed = frame * np.hanning(frame_size)` <br /> `fft_mag = np.abs(np.fft.fft(windowed))` <br /> `mid_energy = np.mean(fft_mag[mid_idx:high_idx])` <br /> `high_energy = np.mean(fft_mag[high_idx:])` <br /> `spectral_slope_db = 20 * np.log10(high_energy / mid_energy)` <br /> `avg_spectral_slope_db = np.mean([artifacts['spectral_slope_db']])`
|`quantization::std_spectral_slope_db`| Dithering Stability (dB) | `dither st` | 0 to 30 dB | Unipolar `(0, 1)` <br /> Inverted sigmoid normalization: <br /> -- 0.0 dB → 0.95 (perfect consistency), <br /> -- 15.0 dB → 0.05 (high variability). <br /> Maps spectral slope variability to dithering stability - lower standard deviation indicates more consistent quantization behavior. | Standard deviation of spectral slope measurements across all frames in the bandpass-filtered signal. Measures the consistency of high-frequency rolloff characteristics. Lower values indicate stable quantization behavior, higher values suggest variable or problematic dithering. | spectral slope standard deviation from FFT analysis: <br /> `windowed = frame * np.hanning(frame_size)` <br /> `fft_mag = np.abs(np.fft.fft(windowed))` <br /> `spectral_slope_db = 20 * np.log10(high_energy / mid_energy)` <br /> `std_spectral_slope_db = np.std([artifacts['spectral_slope_db']])`
|`quantization::unique_levels`| Digital Resolution | `digit.res` | 1 to 1000000 levels | Unipolar `(0, 1)` <br /> Logarithmic normalization: <br /> -- 100 levels → 0.0 (poor quality), <br /> -- 100000 levels → 0.95 (excellent quality). <br /> Maps number of unique amplitude levels to digital resolution quality - higher values indicate finer quantization resolution. | Number of unique amplitude levels detected in the bandpass-filtered signal with tolerance for floating point precision. Measures the granularity of the digital audio quantization. More unique levels indicate higher resolution and less coarse quantization. | unique amplitude level counting with tolerance: <br /> `signal = signal - np.mean(signal)` <br /> `sorted_signal = np.sort(np.abs(signal[signal != 0]))` <br /> `unique_levels = count_unique_with_tolerance(sorted_signal, tolerance)` <br /> `num_levels = len(unique_levels)`
|`quantization::estimated_bits`| Estimated Bit Depth | `bit depth` | 1 to 32 bits | Unipolar `(0, 1)` <br /> Sigmoid normalization: <br /> -- 6.0 bits → 0.05 (very poor), <br /> -- 24.0 bits → 0.95 (excellent quality). <br /> Maps effective bit depth to audio quality - higher values indicate better quantization resolution. | Estimated effective bit depth of the bandpass-filtered signal by analyzing quantization levels. Measures the resolution of the digital audio quantization. Higher bit depths indicate finer amplitude resolution and lower quantization noise. | bit depth estimation from unique amplitude levels: <br /> `signal = signal - np.mean(signal)` <br /> `sorted_signal = np.sort(np.abs(signal[signal != 0]))` <br /> `unique_levels = count_unique_with_tolerance(sorted_signal)` <br /> `estimated_bits = np.log2(num_levels * 2)`


### All Metrics (JSON and image)

#### `dynamics`, `dynamics_full_spectrum`

|key|title|label|def. range|norm. fn|description|algo (py)
|--|--|--|--|--|--|--
|`dynamics::peak_dbfs`| Peak Level (dBFS) | - | -96 to 0 dBFS | - | Maximum absolute amplitude of the bandpass-filtered signal in dBFS. Represents the loudest instantaneous sample within the frequency band during the 30-second chunk. | max absolute amplitude of the bandpass-filtered signal, in dBFS, where signal is bandpass-filtered using 4th-order Butterworth filter: <br /> `peak = np.max(np.abs(signal))` <br /> `peak_db = 20 * np.log10(peak)  # if peak > 0 else -inf`
|`dynamics::rms_dbfs`| RMS Level (dBFS) | - | -96 to 0 dBFS | - | Root mean square amplitude of the bandpass-filtered signal in dBFS. Represents the average power level within the frequency band during the 30-second chunk, providing a measure of perceived loudness. | root mean square amplitude of the bandpass-filtered signal, in dBFS: <br /> `rms = np.sqrt(np.mean(signal ** 2))` <br/> `rms_dbfs = 20 * np.log10(rms)  # if rms > 0 else -inf`
|`dynamics::crest_factor_db`| Crest Factor (dB) | `dynamics` | 0 to 96 dB | Unipolar `(0, 1)` <br /> Sigmoid normalization: <br /> -- 3 dB → 0.05 (compressed), <br /> -- 20 dB → 0.95 (natural dynamics). <br /> Maps heavily compressed audio to low values, natural dynamics to high values. | Difference between peak and RMS level of the bandpass-filtered signal. Indicates the dynamic character of the frequency band - lower values suggest more compressed/consistent levels, higher values indicate more transient/impulsive content. | difference between peak and RMS level of the bandpass-filtered signal: <br /> `crest_factor_db = peak_dbfs - rms_dbfs  # only if both are not -inf`
|`dynamics::peak_dyn_range_db`| Peak Dynamic Range (dB) | - | 0 to 120 dB | - | Dynamic range between the quietest and loudest frame peaks within the frequency band. Measures the difference between minimum and maximum peak levels across all frames - higher values indicate greater contrast between quiet and loud moments. | dynamic range of frame-wise peak amplitudes, in dB: <br /> `min_peak = np.min(frame_peaks)` <br/> `max_peak = np.max(frame_peaks)` <br/> `peak_range_db = 20 * np.log10(max_peak / min_peak)  # or use noise floor if min_peak ~ 0`
|`dynamics::rms_dyn_range_db`| RMS Dynamic Range (dB) | - | 0 to 120 dB | - | Dynamic range between the quietest and loudest frame RMS levels within the frequency band. Measures the difference between minimum and maximum RMS levels across all frames - higher values indicate greater contrast between quiet and loud sustained periods. | dynamic range of frame-wise RMS amplitudes, in dB: <br /> `min_rms = np.min(frame_rms)` <br/> `max_rms = np.max(frame_rms)` <br/> `rms_range_db = 20 * np.log10(max_rms / min_rms)  # or use noise floor if min_rms ~ 0`
|`dynamics::avg_crest_factor_db`| Crest Frame Factor Avg. (dB) | `avg.dyn` | 0 to 96 dB | Unipolar `(0, 1)` <br /> Sigmoid normalization: <br /> -- 3 dB → 0.05 (compressed), <br /> -- 16 dB → 0.95 (natural dynamics). <br /> Maps heavily compressed audio to low values, natural dynamics to high values. | Mean crest factor across all frames within the frequency band, using noise floor for zero-RMS frames. Represents the average ratio of peak-to-RMS levels throughout the chunk - higher values indicate consistently transient/impulsive content, lower values suggest more sustained character. | mean crest factor across all frames, using noise floor for zero-RMS frames: <br /> `frame_crest_factors = [peak / max(rms, 1e-12) for peak, rms in zip(frame_peaks, frame_rms)]` <br/> `avg_crest_factor = np.mean(frame_crest_factors)` <br/> `avg_crest_factor_db = 20 * np.log10(avg_crest_factor)`
|`dynamics::std_crest_factor_db`| Crest Frame Factor Std. (dB) | - | 0 to 6 dB | - | Standard deviation of frame crest factors within the frequency band. Measures the variability of peak-to-RMS ratios across frames in dB units - higher values indicate inconsistent dynamic character (mix of transient and sustained content), lower values suggest consistent behavior. | standard deviation of frame crest factors in dB: <br /> `frame_crest_factors_db = [20 * log10(peak / max(rms, 1e-12)) for peak, rms in zip(frame_peaks, frame_rms)]` <br/> `std_crest_factor_db = np.std(frame_crest_factors_db)`
|`dynamics_full_spectrum::peak_dbfs`| Peak Level (dBFS) | - | -96 to 0 dBFS | - | Maximum absolute amplitude of the full-spectrum signal in dBFS. Represents the loudest instantaneous sample during the 30-second chunk. | max absolute amplitude of the full-spectrum signal, in dBFS: <br /> `peak = np.max(np.abs(signal))` <br /> `peak_dbfs = 20 * np.log10(peak)  # if peak > 0 else -inf`
|`dynamics_full_spectrum::rms_dbfs`| RMS Level (dBFS) | - | -96 to 0 dBFS | - | Root mean square amplitude of the full-spectrum signal in dBFS. Represents the average power level during the 30-second chunk, providing a measure of perceived loudness. | root mean square amplitude of the full-spectrum signal, in dBFS: <br /> `rms = np.sqrt(np.mean(signal ** 2))` <br/> `rms_dbfs = 20 * np.log10(rms)  # if rms > 0 else -inf`
|`dynamics_full_spectrum::crest_factor_db`| Crest Factor (dB) | - | 0 to 96 dB | - | Difference between peak and RMS level of the full-spectrum signal. Indicates the dynamic character - lower values suggest more compressed/consistent levels, higher values indicate more transient/impulsive content. | difference between peak and RMS level of the full-spectrum signal: <br /> `crest_factor_db = peak_dbfs - rms_dbfs  # only if both are not -inf`
|`dynamics_full_spectrum::peak_dyn_range_db`| Peak Dynamic Range (dB) | - | 0 to 120 dB | - | Dynamic range between the quietest and loudest frame peaks in the full-spectrum signal. Measures the difference between minimum and maximum peak levels across all frames - higher values indicate greater contrast between quiet and loud moments. | dynamic range of frame-wise peak amplitudes, in dB: <br /> `min_peak = np.min(frame_peaks)` <br/> `max_peak = np.max(frame_peaks)` <br/> `peak_range_db = 20 * np.log10(max_peak / min_peak)  # or use noise floor if min_peak ~ 0`
|`dynamics_full_spectrum::rms_dyn_range_db`| RMS Dynamic Range (dB) | - | 0 to 120 dB | - | Dynamic range between the quietest and loudest frame RMS levels in the full-spectrum signal. Measures the difference between minimum and maximum RMS levels across all frames - higher values indicate greater contrast between quiet and loud sustained periods. | dynamic range of frame-wise RMS amplitudes, in dB: <br /> `min_rms = np.min(frame_rms)` <br/> `max_rms = np.max(frame_rms)` <br/> `rms_range_db = 20 * np.log10(max_rms / min_rms)  # or use noise floor if min_rms ~ 0`
|`dynamics_full_spectrum::avg_crest_factor_db`| Crest Frame Factor Avg. (dB) | - | 0 to 96 dB | - | Mean crest factor across all frames in the full-spectrum signal, using noise floor for zero-RMS frames. Represents the average ratio of peak-to-RMS levels throughout the chunk - higher values indicate consistently transient/impulsive content, lower values suggest more sustained character. | mean crest factor across all frames, using noise floor for zero-RMS frames: <br /> `frame_crest_factors = [peak / max(rms, 1e-12) for peak, rms in zip(frame_peaks, frame_rms)]` <br/> `avg_crest_factor = np.mean(frame_crest_factors)` <br/> `avg_crest_factor_db = 20 * np.log10(avg_crest_factor)`
|`dynamics_full_spectrum::std_crest_factor_db`| Crest Frame Factor Std. (dB) | - | 0 to 6 dB | - | Standard deviation of frame crest factors in the full-spectrum signal. Measures the variability of peak-to-RMS ratios across frames in dB units - higher values indicate inconsistent dynamic character (mix of transient and sustained content), lower values suggest consistent behavior. | standard deviation of frame crest factors in dB: <br /> `frame_crest_factors_db = [20 * log10(peak / max(rms, 1e-12)) for peak, rms in zip(frame_peaks, frame_rms)]` <br/> `std_crest_factor_db = np.std(frame_crest_factors_db)`


#### `freq_response`

|key|title|label|def. range|norm. fn|description|algo (py)
|--|--|--|--|--|--|--
|`freq_response::avg_magnitude_db`| Relative Frequency Balance (dB) | `energy` | -60 to 30 dB | Bipolar `(-1, 1)` <br /> Sigmoid normalization: <br /> -- -3 dB → 0.0 (neutral), <br /> -- -30 dB → -0.95 (low extreme), <br /> -- 10 dB → 0.95 (high extreme). <br /> Maps frequency balance relative to uniform distribution. | Relative energy density of the frequency band compared to uniform distribution across the 20 Hz to 21,000 Hz analysis range. Calculated using overlapping FFT frames with Hanning window. Positive values indicate the band is louder than average, negative values indicate it's quieter than average. | FFT-based frequency analysis with overlapping frames: <br /> `windowed = frame * np.hanning(fft_size)` <br /> `fft_mag = np.abs(np.fft.rfft(windowed))` <br /> `avg_fft = np.mean(frames_ffts, axis=0)` <br /> `band_energy_density = band_energy / band_width` <br /> `balance_db = 20 * np.log10(band_energy_density / expected_energy_density)`


#### `harmonics`, `harmonics_full_spectrum`

|key|title|label|def. range|norm. fn|description|algo (py)
|--|--|--|--|--|--|--
|`harmonics::spectral_centroid_fraction`| Spectral Centroid Fraction | `brightness` | 0.0 to 1.0 | Unipolar `(0, 1)` <br /> Simple clipping: <br /> -- 0.0 → warmer (energy at bottom of band), <br /> -- 1.0 → brighter (energy at top of band). <br /> Normalized position of spectral centroid within each frequency band. | Spectral centroid (center of mass of frequency spectrum) calculated within each bandpass-filtered frequency band and normalized to 0-1 range relative to band boundaries. Measures brightness/warmth characteristics within specific frequency ranges. 0.0 indicates energy concentrated at lower frequencies of the band (warmer), 1.0 indicates energy concentrated at higher frequencies of the band (brighter). | Per-band spectral centroid analysis using overlapping FFT frames: <br /> `band_signal = bandpass(data, rate, f_low, f_high)` <br /> `windowed = frame * np.hanning(fft_size)` <br /> `fft = np.fft.rfft(windowed)` <br /> `frequencies = np.fft.rfftfreq(fft_size, 1/sample_rate)` <br /> `band_mask = (frequencies >= f_low) & (frequencies <= f_high)` <br /> `centroid = np.sum(band_freqs * band_mags) / np.sum(band_mags)` <br /> `centroid_fraction = (centroid - f_low) / (f_high - f_low)`
|`harmonics::spectral_rolloff_fraction`| Spectral Rolloff Fraction | `fullness` | 0.0 to 1.0 | Unipolar `(0, 1)` <br /> Simple clipping: <br /> -- 0.0 → concentrated (energy in lower part of band), <br /> -- 1.0 → full spectrum (energy spread throughout band). <br /> Normalized position of 85% energy rolloff point within each frequency band. | Spectral rolloff point (frequency below which 85% of energy is contained) calculated within each bandpass-filtered frequency band and normalized to 0-1 range relative to band boundaries. Measures energy distribution characteristics within specific frequency ranges. 0.0 indicates concentrated energy in lower part of band, 1.0 indicates energy spread throughout the entire band. | Per-band spectral rolloff analysis using overlapping FFT frames: <br /> `band_signal = bandpass(data, rate, f_low, f_high)` <br /> `windowed = frame * np.hanning(fft_size)` <br /> `fft = np.fft.rfft(windowed)` <br /> `band_mask = (frequencies >= f_low) & (frequencies <= f_high)` <br /> `cumulative = np.cumsum(band_mags**2)` <br /> `rolloff_idx = np.where(cumulative >= 0.85 * cumulative[-1])[0][0]` <br /> `rolloff_freq = band_freqs[rolloff_idx]` <br /> `rolloff_fraction = (rolloff_freq - f_low) / (f_high - f_low)`
|`harmonics_full_spectrum::overall_spectral_flatness_ratio`| Spectral Flatness Ratio | - | 0.0 to 1.0 | - | Spectral flatness of the full-spectrum signal up to 16kHz band limit. Measures how tonal vs. noise-like the signal is. Higher values indicate more noise-like content, lower values indicate more harmonic/tonal content. Raw ratio without dB conversion. | spectral flatness analysis using overlapping FFT frames with band limiting: <br /> `windowed = frame * np.hanning(fft_size)` <br /> `mag = np.abs(np.fft.rfft(windowed))[:spectrum_bins]` <br /> `geo_mean = np.exp(np.mean(np.log(mag_spectrum)))` <br /> `arith_mean = np.mean(mag_spectrum)` <br /> `flatness_ratio = geo_mean / arith_mean`
|`harmonics_full_spectrum::std_overall_spectral_flatness_ratio`| Spectral Flatness Variation | - | 0.0 to 0.25 | - | Standard deviation of spectral flatness values across time frames from full-spectrum signal up to 16kHz band limit. Measures consistency of tonal vs. noise-like characteristics over time. Lower values indicate consistent spectral character, higher values indicate high variation in spectral content or dynamic arrangements. | Standard deviation calculation of spectral flatness across overlapping FFT frames: <br /> `flatness_values = []` for each frame <br /> `windowed = frame * np.hanning(fft_size)` <br /> `mag = np.abs(np.fft.rfft(windowed))[:spectrum_bins]` <br /> `flatness = geo_mean / arith_mean` <br /> `std_flatness = np.std(flatness_values)`

#### `quantization`, `quantization_full_spectrum`

|key|title|label|def. range|norm. fn|description|algo (py)
|--|--|--|--|--|--|--
|`quantization::estimated_bits`| Estimated Bit Depth | `bit depth` | 1 to 32 bits | Unipolar `(0, 1)` <br /> Sigmoid normalization: <br /> -- 6.0 bits → 0.05 (very poor), <br /> -- 24.0 bits → 0.95 (excellent quality). <br /> Maps effective bit depth to audio quality - higher values indicate better quantization resolution. | Estimated effective bit depth of the bandpass-filtered signal by analyzing quantization levels. Measures the resolution of the digital audio quantization. Higher bit depths indicate finer amplitude resolution and lower quantization noise. | bit depth estimation from unique amplitude levels: <br /> `signal = signal - np.mean(signal)` <br /> `sorted_signal = np.sort(np.abs(signal[signal != 0]))` <br /> `unique_levels = count_unique_with_tolerance(sorted_signal)` <br /> `estimated_bits = np.log2(num_levels * 2)`
|`quantization::unique_levels`| Digital Resolution | `digit.res` | 1 to 1000000 levels | Unipolar `(0, 1)` <br /> Logarithmic normalization: <br /> -- 100 levels → 0.0 (poor quality), <br /> -- 100000 levels → 0.95 (excellent quality). <br /> Maps number of unique amplitude levels to digital resolution quality - higher values indicate finer quantization resolution. | Number of unique amplitude levels detected in the bandpass-filtered signal with tolerance for floating point precision. Measures the granularity of the digital audio quantization. More unique levels indicate higher resolution and less coarse quantization. | unique amplitude level counting with tolerance: <br /> `signal = signal - np.mean(signal)` <br /> `sorted_signal = np.sort(np.abs(signal[signal != 0]))` <br /> `unique_levels = count_unique_with_tolerance(sorted_signal, tolerance)` <br /> `num_levels = len(unique_levels)`
|`quantization::avg_spectral_slope_db`| Dithering Quality (dB) | `dither Q` | -60 to 20 dB | Bipolar `(-1, 1)` <br /> Sigmoid normalization: <br /> -- -20.0 dB → 0.95 (natural rolloff, good), <br /> -- -5.0 dB → 0.0 (moderate rolloff, neutral), <br /> -- 10.0 dB → -0.95 (flat/boosted highs, poor). <br /> Maps spectral slope to dithering quality - steeper negative slopes indicate better quantization behavior. | Average spectral slope between mid and high frequencies in the bandpass-filtered signal. Measures the high-frequency rolloff characteristics which indicate quantization noise patterns. Steeper negative slopes suggest natural rolloff, flatter slopes indicate quantization artifacts or poor dithering. | spectral slope calculation from FFT analysis: <br /> `windowed = frame * np.hanning(frame_size)` <br /> `fft_mag = np.abs(np.fft.fft(windowed))` <br /> `mid_energy = np.mean(fft_mag[mid_idx:high_idx])` <br /> `high_energy = np.mean(fft_mag[high_idx:])` <br /> `spectral_slope_db = 20 * np.log10(high_energy / mid_energy)` <br /> `avg_spectral_slope_db = np.mean([artifacts['spectral_slope_db']])`
|`quantization::std_spectral_slope_db`| Dithering Stability (dB) | `dither st` | 0 to 30 dB | Unipolar `(0, 1)` <br /> Inverted sigmoid normalization: <br /> -- 0.0 dB → 0.95 (perfect consistency), <br /> -- 15.0 dB → 0.05 (high variability). <br /> Maps spectral slope variability to dithering stability - lower standard deviation indicates more consistent quantization behavior. | Standard deviation of spectral slope measurements across all frames in the bandpass-filtered signal. Measures the consistency of high-frequency rolloff characteristics. Lower values indicate stable quantization behavior, higher values suggest variable or problematic dithering. | spectral slope standard deviation from FFT analysis: <br /> `windowed = frame * np.hanning(frame_size)` <br /> `fft_mag = np.abs(np.fft.fft(windowed))` <br /> `spectral_slope_db = 20 * np.log10(high_energy / mid_energy)` <br /> `std_spectral_slope_db = np.std([artifacts['spectral_slope_db']])`
|`quantization_full_spectrum::left_estimated_bits` <br /> `quantization_full_spectrum::right_estimated_bits` <br /> `quantization_full_spectrum::mono_estimated_bits`| Estimated Bit Depth | - | 1 to 32 bits | - | Estimated effective bit depth of the full-spectrum signal by analyzing quantization levels. Measures the resolution of the digital audio quantization. Higher bit depths indicate finer amplitude resolution and lower quantization noise. | bit depth estimation from unique amplitude levels: <br /> `signal = signal - np.mean(signal)` <br /> `sorted_signal = np.sort(np.abs(signal[signal != 0]))` <br /> `unique_levels = count_unique_with_tolerance(sorted_signal)` <br /> `estimated_bits = np.log2(num_levels * 2)`
|`quantization_full_spectrum::left_unique_levels` <br /> `quantization_full_spectrum::right_unique_levels` <br /> `quantization_full_spectrum::mono_unique_levels`| Digital Resolution | - | 1 to 1000000 levels | - | Number of unique amplitude levels detected in the full-spectrum signal with tolerance for floating point precision. Measures the granularity of the digital audio quantization. More unique levels indicate higher resolution and less coarse quantization. | unique amplitude level counting with tolerance: <br /> `signal = signal - np.mean(signal)` <br /> `sorted_signal = np.sort(np.abs(signal[signal != 0]))` <br /> `unique_levels = count_unique_with_tolerance(sorted_signal, tolerance)` <br /> `num_levels = len(unique_levels)`
|`quantization_full_spectrum::left_avg_spectral_slope_db` <br /> `quantization_full_spectrum::right_avg_spectral_slope_db` <br /> `quantization_full_spectrum::mono_avg_spectral_slope_db`| Dithering Quality (dB) | - | -60 to 20 dB | - | Average spectral slope between mid and high frequencies in the full-spectrum signal. Measures the high-frequency rolloff characteristics which indicate quantization noise patterns. Steeper negative slopes suggest natural rolloff, flatter slopes indicate quantization artifacts or poor dithering. | spectral slope calculation from FFT analysis: <br /> `windowed = frame * np.hanning(frame_size)` <br /> `fft_mag = np.abs(np.fft.fft(windowed))` <br /> `mid_energy = np.mean(fft_mag[mid_idx:high_idx])` <br /> `high_energy = np.mean(fft_mag[high_idx:])` <br /> `spectral_slope_db = 20 * np.log10(high_energy / mid_energy)` <br /> `avg_spectral_slope_db = np.mean([artifacts['spectral_slope_db']])`
|`quantization_full_spectrum::left_std_spectral_slope_db` <br /> `quantization_full_spectrum::right_std_spectral_slope_db` <br /> `quantization_full_spectrum::mono_std_spectral_slope_db`| Dithering Stability (dB) | - | 0 to 30 dB | - | Standard deviation of spectral slope measurements across all frames in the full-spectrum signal. Measures the consistency of high-frequency rolloff characteristics. Lower values indicate stable quantization behavior, higher values suggest variable or problematic dithering. | spectral slope standard deviation from FFT analysis: <br /> `windowed = frame * np.hanning(frame_size)` <br /> `fft_mag = np.abs(np.fft.fft(windowed))` <br /> `spectral_slope_db = 20 * np.log10(high_energy / mid_energy)` <br /> `std_spectral_slope_db = np.std([artifacts['spectral_slope_db']])`

#### `sparkle`

|key|title|label|def. range|norm. fn|description|algo (py)
|--|--|--|--|--|--|--
|`sparkle::sparkle`| Sparkle | `sparkle` | 0.0 to 2.0 | Unipolar `(0, 1)` <br /> Hybrid normalization: <br /> -- Linear up to 0.3 → 0.95, <br /> -- Exponential above 0.3 → 1.0. <br /> Maps high-frequency transient energy to sparkle perception - higher values indicate more high-frequency detail and brightness. | RMS energy of transients in the bandpass-filtered signal with bandwidth compensation. Measures high-frequency content and transient detail. Set to 0.0 for bands below 2kHz threshold. Higher values indicate more sparkle and high-frequency energy. | transient RMS calculation with bandwidth compensation: <br /> `frame = signal[i:i+frame_size]` <br /> `rms = np.sqrt(np.mean(np.square(frame)))` <br /> `sparkle_value = np.mean(frame_energy)` <br /> `band_octaves = np.log2(f_high / f_low)` <br /> `compensation_factor = total_octaves / band_octaves` <br /> `sparkle_compensated = sparkle_value * compensation_factor`

#### `stereo_correlation`, `stereo_phase`, `stereo_width`

|key|title|label|def. range|norm. fn|description|algo (py)
|--|--|--|--|--|--|--
|`stereo_correlation::correlation`| Stereo Correlation | `st.corr` | -1.0 to 1.0 | Bipolar `(-1, 1)` <br /> Linear clipping normalization: <br /> -- -1.0 → -1.0 (anti-correlated), <br /> -- 0.0 → 0.0 (uncorrelated), <br /> -- 1.0 → 1.0 (perfectly correlated). <br /> Maps linear relationship between stereo channels - values indicate amplitude correlation between left and right channels. | Correlation coefficient between left and right channels in the bandpass-filtered signal. Measures the similarity between stereo channels within the frequency band. Values near 1.0 indicate highly correlated (mono-like) content, values near 0.0 indicate uncorrelated content, and values near -1.0 indicate anti-correlated content. | stereo correlation calculation using Pearson correlation: <br /> `left_band = bandpass(left, rate, f_low, f_high)` <br /> `right_band = bandpass(right, rate, f_low, f_high)` <br /> `correlation = np.corrcoef(left_band, right_band)[0, 1]`
|`stereo_phase::coherence`| Stereo Phase Coherence | `st.phase` | -1.0 to 1.0 | Bipolar `(-1, 1)` <br /> Linear clipping normalization: <br /> -- -1.0 → -1.0 (perfect anti-phase), <br /> -- 0.0 → 0.0 (random phases), <br /> -- +1.0 → +1.0 (perfect in-phase). <br /> Maps phase relationship between stereo channels - values indicate degree of phase alignment across frequency spectrum. | Phase coherence between left and right channels in the bandpass-filtered signal using windowed FFT phase analysis. Measures energy-weighted phase alignment of stereo channels within the frequency band. Values near +1.0 indicate strong in-phase coherence (mono-like content), values near 0.0 indicate random phase relationships (wide stereo content), values near -1.0 indicate anti-phase relationships (mono cancellation risk). **Note: Slower analysis due to FFT processing with overlapping windows.** | Energy-weighted phase coherence calculation using overlapping FFT windows: <br /> `left_fft = np.fft.fft(left_windowed)` <br /> `right_fft = np.fft.fft(right_windowed)` <br /> `phase_diff = np.angle(left_fft) - np.angle(right_fft)` <br /> `weights = (left_mag² + right_mag²) / sum(energies)` <br /> `coherence = np.average(np.cos(phase_diff), weights=weights)` <br /> Averaged across overlapping time windows (75% overlap by default)
|`stereo_width::mid_rms`| Mid Channel RMS (dBFS) | - | -96 to 0 dBFS | - | RMS level of the mid (sum) component in the bandpass-filtered signal. Calculated as the average of left and right channels, representing the mono/center content within the frequency band. Higher values indicate stronger center-positioned content. | mid/side processing and RMS calculation: <br /> `left_band = bandpass(left, rate, f_low, f_high)` <br /> `right_band = bandpass(right, rate, f_low, f_high)` <br /> `mid = 0.5 * (left_band + right_band)` <br /> `mid_rms = 20 * np.log10(np.sqrt(np.mean(mid ** 2)))`
|`stereo_width::side_rms`| Side Channel RMS (dBFS) | - | -96 to 0 dBFS | - | RMS level of the side (difference) component in the bandpass-filtered signal. Calculated as the difference of left and right channels, representing the stereo/width content within the frequency band. Higher values indicate stronger stereo width and spatial information. | mid/side processing and RMS calculation: <br /> `left_band = bandpass(left, rate, f_low, f_high)` <br /> `right_band = bandpass(right, rate, f_low, f_high)` <br /> `side = 0.5 * (left_band - right_band)` <br /> `side_rms = 20 * np.log10(np.sqrt(np.mean(side ** 2)))`
|`stereo_width::width_ratio`| Stereo Width Ratio | drawn as `st.presence`, `st.natrl` | 0.0 to ∞ | - | Ratio of side channel amplitude to mid channel amplitude in the bandpass-filtered signal. Measures stereo width within the frequency band. Lower values indicate mono-like content, higher values indicate wider stereo image. <br /> <br /> Visualized by component via `stereo_width::presence` and `stereo_width::quality` | mid/side amplitude ratio calculation: <br /> `mid = 0.5 * (left_band + right_band)` <br /> `side = 0.5 * (left_band - right_band)` <br /> `width_ratio = 10^(side_rms/20) / 10^(mid_rms/20)`
|`stereo_width::presence`| Stereo Presence | `st.presence` | 0.0 to 1.0 | Unipolar `(0, 1)` <br /> Linear clipping normalization: <br /> -- 0.0 → 0.0 (no stereo presence), <br /> -- 1.0 → 1.0 (full stereo presence). <br /> Maps stereo width to presence perception using exponential saturation curve. | Stereo presence derived from width ratio using exponential approach to saturation. Measures the perceived stereo width within the frequency band. Values approach 1.0 asymptotically as width increases, representing diminishing returns of very wide stereo content. <br /> <br /> A visualization component of `stereo_width::width_ratio`. | exponential presence calculation from width ratio: <br /> `width_ratio = side_amplitude / mid_amplitude` <br /> `presence = 1 - np.exp(-width_ratio * 2.0 / 2.0)` <br /> `presence = 1 - np.exp(-width_ratio)`
|`stereo_width::quality`| Stereo Naturalness | `st.natrl` | -1.0 to 1.0 | Bipolar `(-1, 1)` <br /> Linear clipping normalization: <br /> -- -1.0 → -1.0 (completely broken), <br /> -- 0.0 → 0.0 (poor quality), <br /> -- 1.0 → 1.0 (perfect quality). <br /> Maps stereo width to naturalness perception using piecewise quality function. | Stereo quality derived from width ratio using piecewise function. Measures the naturalness of stereo width within the frequency band. Values above 0 indicate natural stereo, values below 0 indicate problematic phase or width issues. <br /> <br /> A visualization component of `stereo_width::width_ratio`. | piecewise quality calculation from width ratio: <br /> `if width_ratio < 0.85: quality = 1.0` <br /> `elif width_ratio <= 1.0: quality = 1.0 - (width_ratio - 0.85) / 0.15` <br /> `elif width_ratio <= 1.3: quality = -0.7 * (width_ratio - 1.0) / 0.3` <br /> `else: quality = -1.0`

#### `audio_quality`

|key|title|label|def. range|norm. fn|description|algo (py)
|--|--|--|--|--|--|--
|`audio_quality::quantization_efficiency`| Quantization Efficiency | `dither.effy` | 0.0 to 1.0+ | Unipolar `(0, 1)` <br /> Triangular normalization: <br /> -- ≤0.25 → 0.0 (underused quantization), <br /> -- 0.575 → 1.0 (natural utilization), <br /> -- ≥0.85 → 0.0 (overused quantization). <br /> Maps ratio of actual to theoretical quantization levels with quality declining away from natural point. Lower values indicate underutilized quantization, higher values indicate overutilized/artificial quantization. | Efficiency ratio of actual unique amplitude levels to theoretical levels based on estimated bit depth. Measures quantization utilization within the frequency band. Values around 0.575 represent natural audio characteristics, while deviation in either direction suggests quality issues - underutilization (too few levels used) or overutilization (unnaturally high level usage). Note: 0.575 as optimal point is an assumption based on typical natural audio behavior. | quantization efficiency calculation: <br /> `theoretical_levels = 2 ** estimated_bits` <br /> `quantization_efficiency = unique_levels / theoretical_levels`
|`audio_quality::overall_spectral_flatness_ratio`| Overall Musicality | `ovrl.mus` | 0.0 to 1.0 | Bipolar `(-1, 1)` <br /> Musical center normalization: <br /> -- 0.3-0.5 → 0.95 (musical sweet spot), <br /> -- 0.4 → 0.95 (optimal musicality), <br /> -- 0.0 or 1.0 → -0.95 (extreme penalty). <br /> Maps spectral flatness to musicality with quality declining away from natural musical range. Values in sweet spot indicate musical content, extreme values indicate pure tones or noise. | Spectral flatness ratio of the full-spectrum signal (all bands have the same value, that ot the full-spectrum analysis) measuring overall musicality. Represents the balance between tonal and noise-like characteristics across the entire frequency range. Values around 0.4 indicate optimal musical content, while values near 0.0 (pure tones) or 1.0 (pure noise) receive negative scores. | spectral flatness ratio from full-spectrum analysis: <br /> `overall_spectral_flatness_ratio = geometric_mean / arithmetic_mean` <br /> `flatness_ratio = geo_mean / arith_mean` <br /> (from harmonics_full_spectrum analysis)
|`audio_quality::std_overall_spectral_flatness_ratio`| Spectral Consistency | `ovrl.var` | 0.0 to 0.25 | Unipolar `(0, 1)` <br /> Consistency normalization: <br /> -- 0.0 → 0.95 (perfect consistency), <br /> -- 0.125 → ~0.5 (moderate variation), <br /> -- 0.25+ → 0.05 (excessive variation). <br /> Lower values indicate more consistent spectral character throughout the audio, higher values indicate high dynamic variation or potential mixing inconsistencies. | Standard deviation of spectral flatness across time frames (all bands have the same value from full-spectrum analysis) measuring spectral consistency. Represents how much the balance between tonal and noise-like characteristics varies over time. Low values indicate consistent spectral character, while high values may indicate very dynamic arrangements or inconsistent processing. | Standard deviation of spectral flatness values from full-spectrum analysis: <br /> `std_spectral_flatness = std(flatness_values_over_time)` <br /> where each flatness value = `geometric_mean / arithmetic_mean` <br /> (from harmonics_full_spectrum analysis)

#### `dynamic_range`

|key|title|label|def. range|norm. fn|description|algo (py)
|--|--|--|--|--|--|--
|`dynamic_range::overall_avg_crest_factor_db`| Overall Average Crest Factor (dB) | `ovrl.dyn` | 0 to 30 dB | Bipolar `(-1, 1)` <br /> Sigmoid normalization: <br /> -- 3.0 dB → -0.95 (heavily compressed), <br /> -- 8.0 dB → 0.0 (neutral dynamics), <br /> -- 16.0 dB → 0.95 (natural dynamics). <br /> Maps overall crest factor to dynamic range quality - higher values indicate more natural, less compressed audio. | Overall average crest factor of the full-spectrum signal (all bands have the same value, that ot the full-spectrum analysis) representing the global dynamic character. Measures the average peak-to-RMS ratio across all frames in the entire frequency spectrum. Higher values indicate more natural dynamics, lower values suggest compression or limiting. | overall crest factor from full-spectrum dynamics analysis: <br /> `overall_avg_crest_factor_db = dynamics_full_spectrum_avg_crest_factor_db`
|`dynamic_range::overall_std_crest_factor_db`| Overall Standard Deviation Crest Factor (dB) | `ovrl.dyn.var` | 0 to 4 dB | Bipolar `(-1, 1)` <br /> Sigmoid normalization: <br /> -- 0.0 dB → -0.95 (overly uniform), <br /> -- 2.0 dB → 0.0 (neutral consistency), <br /> -- 4.0 dB → 0.95 (high variability). <br /> Maps crest factor variability to dynamic consistency - higher values indicate more variable dynamics across frames. | Overall standard deviation of crest factor of the full-spectrum signal (all bands have the same value, that of the full-spectrum analysis) representing the global dynamic variability. Measures the consistency of peak-to-RMS ratios across all frames in the entire frequency spectrum. Higher values indicate more variable dynamics between frames, lower values suggest consistent processing or uniform material. | overall crest factor standard deviation from full-spectrum dynamics analysis: <br /> `overall_std_crest_factor_db = dynamics_full_spectrum_std_crest_factor_db`
